IntegerTest = TestCase (

testBenchFib = (
	self assert: (0 benchFib = 1).
	self assert: (1 benchFib = 1).
	self assert: (2 benchFib = 3).
)

testBitLogic = (
	"This little suite of tests is designed to verify correct operation of most
	of Squeak's bit manipulation code, including two's complement
	representation of negative values.  It was written in a hurry and
	is probably lacking several important checks."
	"self run: #testBitLogic"
	| n |
	"Shift 1 bit left then right and test for 1"
	1 to: 60 do: [:i | self assert: ((1 bitShift: i) bitShift: i negated) = 1].
	"Shift -1 left then right and test for 1"
	1 to: 60 do: [:i | self assert: ((-1 bitShift: i) bitShift: i negated) = -1].
	"And a single bit with -1 and test for same value"
	1 to: 60 do: [:i | self assert: ((1 bitShift: i) bitAnd: -1) = (1 bitShift: i)].
	"Verify that (n bitAnd: n negated) = n for single bits"
	1 to: 60 do: [:i |  n := 1 bitShift: i. self assert: (n bitAnd: n negated) = n].
	"Verify that n negated = (n complemented + 1) for single bits"
	1 to: 60 do: [:i |
					n := 1 bitShift: i.
					self assert: n negated = ((n bitXor: -1) + 1)].
	"Verify that (n + n complemented) = -1 for single bits"
	1 to: 60 do: [:i |
					n := 1 bitShift: i.
					self assert: (n + (n bitXor: -1)) = -1].
	"Verify that n negated = (n complemented +1) for single bits"
	1 to: 60 do: [:i |
					n := 1 bitShift: i.
					self assert: n negated = ((n bitXor: -1) + 1)].
	self assert: (-2 bitAnd: 4294967295) = 4294967294.
)

testCrossSumBase = (
	"self run: #testCrossSumBase"
	self assert: (
		((-20 to: 20) collect: [:each | each crossSumBase: 10]) asArray =
		#(2 10 9 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 10 2)).
	self assert: (
		((-20 to: 20) collect: [:each | each crossSumBase: 2]) asArray =
		#(2 3 2 2 1 4 3 3 2 3 2 2 1 3 2 2 1 2 1 1 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2)).
)

testDegreeCos = (
	"self run: #testDegreeCos"
	"Following tests use approximate equality, because cosine are generally evaluated using inexact Floating point arithmetic"
	self assert: (45 degreeCos squared - (1/2)) abs <= Float epsilon.
	self assert: (60 degreeCos - (1/2)) abs <= Float epsilon.
	self assert: (120 degreeCos + (1/2)) abs <= Float epsilon.
	-360 to: 360 do: [:i |
		self assert: (i degreeCos closeTo: i degreesToRadians cos)].
	"Following tests use strict equality which is a requested property of degreeCos"
	-10 to: 10 do: [:k |
		self assert: (k*360 + 90) degreeCos = 0.
		self assert: (k*360 - 90) degreeCos = 0.
		self assert: (k*360 + 180) degreeCos + 1 = 0.
		self assert: (k*360) degreeCos - 1 = 0.].
)

testDegreeSin = (
	"self run: #testDegreeSin"
	"Following tests use approximate equality, because sine are generally evaluated using inexact Floating point arithmetic"
	self assert: (45 degreeSin squared - (1/2)) abs <= Float epsilon.
	self assert: (30 degreeSin - (1/2)) abs <= Float epsilon.
	self assert: (-30 degreeSin + (1/2)) abs <= Float epsilon.
	-360 to: 360 do: [:i |
		self assert: (i degreeSin closeTo: i degreesToRadians sin)].
	"Following tests use strict equality which is a requested property of degreeSin"
	-10 to: 10 do: [:k |
		self assert: (k*360 + 90) degreeSin - 1 = 0.
		self assert: (k*360 - 90) degreeSin + 1= 0.
		self assert: (k*360 + 180) degreeSin = 0.
		self assert: (k*360) degreeSin = 0].
)

testEven = (
	self deny: (1073741825 even).
	self assert: (1073741824  even).
)

testFloorLog = (
	self assert: (100 floorLog: 10) = 2.
)

testIntegerDivision = (
	| suite |
	suite := #( 1 2 5 1000 123456798  111222333444555 ).
	suite := suite , (suite collect: [:e | e negated]).
	suite do: [:a |
		suite do: [:b |
			| q r |
			q := a // b.
			r := a \\ b.
			self assert: b * q + r = a.
			self assert: r abs < b abs.
			self assert: (r isZero or: [b negative = r negative])]].
)

testIntegerReadFrom = (
	self assert: (Integer readFrom: '123' readStream base: 10) = 123.
	self assert: (Integer readFrom: '-123' readStream base: 10) = -123.
	self assert: (Integer readFrom: 'abc' readStream ifFail: [0]) = 0.
	self assert: (Integer readFrom: 'D12' readStream ifFail: [0]) = 0.
	self assert: (Integer readFrom: '1two3' readStream base: 10) = 1.
)

testIsInteger = (
	self assert: (0 isInteger).
)

testIsPowerOfTwo = (
	| powersOfTwo nonPowersOfTwo |
	powersOfTwo := (0 to: 60) collect: [ :each | 2 raisedTo: each ].
	nonPowersOfTwo := (powersOfTwo collect: [ :each | each negated ]),
		#(0 3 -3 5 -5 6 -6 7 -7 9 -9 10 -10 100 -100 1000 -1000 12345678 -12345678 1234567890 -1234567890).
	powersOfTwo do: [ :each |
		self assert: each isPowerOfTwo ].
	nonPowersOfTwo do: [ :each |
		self deny: each isPowerOfTwo ]
)

testIsPrime = (
	| i |
	"Not primes:"
	#(-1000000000000000 -100 -5 -3 -2 -1 0 1) do: [ :each | self deny: each isPrime ].
	"Check all non-negative integers up to one thousand."
	i := 0.
	Integer primesUpTo: 1000 do: [ :prime |
		[ i < prime ] whileTrue: [
			self deny: i isPrime.
			i := i + 1 ].
		self assert: i isPrime.
		i := i + 1 ].
	[ i <= 1000 ] whileTrue: [
		self deny: i isPrime.
		i := i + 1 ].
	"The following tests should return 'true'"
	#(17 78901 104729 15485863 2038074743) do: [ :each |
		self assert: each isPrime ].
	"The following tests should return 'false' (first 5 are Carmichael numbers)"
	#(561 2821 6601 10585 15841 256) do: [ :each |
		self deny: each isPrime ].
)

testIsProbablyPrime = (
	"Not primes:"
	#(-100 -5 -3 -2 -1 0 1) do: [ :each |
		self deny: each isProbablyPrime ].
	"The following tests should return 'true'"
	#(17 78901 104729 15485863 2038074743) do: [ :each |
		self assert: each isProbablyPrime ].
	"The following tests should return 'false' (first 5 are Carmichael integers)"
	#(561 2821 6601 10585 15841 256) do: [ :each |
		self deny: each isProbablyPrime ].
)

testLn = (
	self assert: (100 ln closeTo: 10 ln*2).
)

testLog = (
	self assert: (100 log closeTo: 2).
)

testLowBit = (
	| suite |
	suite := (0 to: 1024 by: 23) asArray , #(65021 65535 4096 16777216 16777217).
	suite do: [:anInteger |
		| lowBit |
		lowBit := (anInteger respondsTo: #bitAt:)
			ifTrue: [(1 to: anInteger highBit) detect: [:bitIndex | (anInteger bitAt: bitIndex) ~= 0] ifNone: [0]]
			ifFalse: [(1 to: anInteger highBit) detect: [:bitIndex | (anInteger bitAnd: (1 bitShift: bitIndex-1)) ~= 0] ifNone: [0]].
		self assert: anInteger lowBit = lowBit.
		self assert: anInteger negated lowBit = lowBit].
)

testPrimesUpTo = (
	| primes nn|
	primes := Integer primesUpTo: 100.
	self assert: primes = #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97).
	"upTo: semantics means 'non-inclusive'"
	primes := Integer primesUpTo: 5.
	self assert: primes = #(2 3).
	"this test is green for nn>25000, see #testLargePrimesUpTo"
	nn := 5.
	self deny: (Integer primesUpTo: nn) last = nn.
	self assert: (Integer primesUpTo: nn + 1) last  = nn.
)

testQuoRem = (
	| suite |
	suite := #( 1 2 5 1000 123456798 111222333444555 ).
	suite := suite , (suite collect: [:e | e negated]).
	suite do: [:a |
		suite do: [:b |
			| q r |
			q := a quo: b.
			r := a rem: b.
			self assert: b * q + r = a.
			self assert: r abs < b abs.
			self assert: (r isZero or: [a negative = r negative])]].
)

testReadFrom = (
	"Ensure remaining characters in a stream are not lost when parsing an integer."
	#(
		('12' 12 '')
		('-350' -350 '')
		('+27' 27 '')
		('25e3 exponent is ignored' 25 'e3 exponent is ignored')
		('25s2 scale is ignored' 25 's2 scale is ignored')
		('25. decimal separator is ignored' 25 '. decimal separator is ignored')
		('25.30 fraction part is ignored' 25 '.30 fraction part is ignored')
		('123r is not a radix specification' 123 'r is not a radix specification')
	) do: [:each |
		[:string :numericValue :expectedRest |
		| readStream result rest |
		readStream := string readStream.
		result := Integer readFrom: readStream.
		rest := readStream upToEnd.
		self assert: result isInteger.
		self assert: result = numericValue.
		self assert: rest = expectedRest.
		] valueWithArguments: each]
)

testSqrtFloor = (
	#(
		0 1 2 3 4 5 10 16 30 160479924 386234481 501619156 524723498 580855366 766098594 834165249 1020363860 1042083924 1049218924
		1459774772895569 3050005981408238 4856589481837079 5650488387708463 7831037396100244) do: [ :each |
			self assert: each asFloat sqrt floor = each sqrtFloor ]
)

testSqrtRem = (
	#(
		0 1 2 3 4 5 10 16 30 160479924 386234481 501619156 524723498 580855366 766098594 834165249 1020363860 1042083924 1049218924
		1459774772895569 3050005981408238 4856589481837079 5650488387708463 7831037396100244) do: [ :each |
			| sr |
			sr := each sqrtRem.
			self assert: sr first squared <= each.
			self assert: (sr first+1) squared > each.
			self assert: sr first squared + sr last = each]
)

testTwoComplementBitLogicWithCarry = (
	"This is non regression test for http://bugs.squeak.org/view.php?id=6874"
	"By property of two complement, following operation is:
	...111110000 this is -16
	...111101111 this is -16-1
	...111100000 this is -32, the result of bitAnd: on two complement
	This test used to fail with n=31 39 47.... because of bug 6874"
	self assert: ((2 to: 80) allSatisfy: [:n | ((2 raisedTo: n) negated bitAnd: (2 raisedTo: n) negated - 1) = (2 raisedTo: n + 1) negated]).
)

testTwoComplementRightShift = (
	"self run: #testTwoComplementRightShift"
	| large small |
	small := 2 << 16.
	large := 2 << 32.
	self assert: ((small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)
		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))).
     self assert: ((small bitShift: -1) ~= (small + 1 bitShift: -1)
		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))).
)

)
