LinkedListTest = ClassTestCase (

| nextLink n list link1 link2 link3 link4 nonEmpty otherList link collectionWithNil collectionWithoutNil nonEmpty1Element collectionWithoutEqualElements elementNotIn elementIn sameAtendAndBegining collection5Elements collectResult |

accessCollection = (
	^collectionWithoutEqualElements
)

anotherElementNotIn = (
	^ elementNotIn
)

anotherElementOrAssociationIn = (
	^ self collection anyOne
)

anotherElementOrAssociationNotIn = (
	^ elementNotIn
)

assertNoDuplicates: aCollection whenConvertedTo: aClass = (
	| result |
	result := self collectionWithEqualElements asIdentitySet.
	self assert: (result class includesBehavior: IdentitySet).
	self collectionWithEqualElements do: [ :initial | self assert: (result occurrencesOf: initial) = 1 ]
)

assertNonDuplicatedContents: aCollection whenConvertedTo: aClass = (
	| result |
	result := aCollection perform: ('as' , aClass name) asSymbol.
	self assert: (result class includesBehavior: aClass).
	result do:
		[ :each |
		self assert: (aCollection occurrencesOf: each) = (result occurrencesOf: each) ].
	^ result
)

assertSameContents: aCollection whenConvertedTo: aClass = (
	| result |
	result := self assertNonDuplicatedContents: aCollection whenConvertedTo: aClass.
	self assert: result size = aCollection size
)

collection = (
	^ self nonEmpty
)

collectionClass = (
	^ LinkedList
)

collectionMoreThan1NoDuplicates = (
	^ collectionWithoutEqualElements
)

collectionNotIncluded = (
	^ collectionWithoutNil
)

collectionWith1TimeSubcollection = (
	^ self oldSubCollection
)

collectionWithCopyNonIdentical = (
	^ collectionWithoutEqualElements
)

collectionWithElement = (
	^ self collection
)

collectionWithElementsToRemove = (
	^ self nonEmpty
)

collectionWithSortableElements = (
	^ collection5Elements
)

collectionWithoutEqualElements = (
	^collectionWithoutEqualElements
)

collectionWithoutNilElements = (
	^collectionWithoutNil
)

containsAll: union of: one andOf: another = (
	self assert: (one allSatisfy: [:each | union includes: each]).
	self assert: (another allSatisfy: [:each | union includes: each])
)

element = (
	^ link ifNil: [link := ValueLink value: 42.]
)

elementInForElementAccessing = (
	^ elementIn
)

elementInForIndexAccessing = (
	^ elementIn
)

elementNotIn = (
	^ Link new
)

elementNotInForElementAccessing = (
	^ elementNotIn
)

elementNotInForIndexAccessing = (
	^ elementNotIn
)

elementNotInForOccurrences = (
	^ elementNotIn
)

elementToAdd = (
	^ ValueLink value: 77
)

empty = (
	^ list
)

firstIndexesOf: aSubCollection in: collection = (
	| tmp result currentIndex |
	tmp:= collection.
	result:= OrderedCollection new.
	currentIndex := 1.
	[tmp isEmpty ]whileFalse:
		[
		(tmp beginsWith: aSubCollection)
			ifTrue: [
				result add: currentIndex.
				1 to: aSubCollection size do:
					[:i |
					tmp := tmp allButFirst.
					currentIndex := currentIndex + 1]
				]
			ifFalse: [
				tmp := tmp allButFirst.
				currentIndex := currentIndex +1.
				]
		 ].
	^ result.
)

howMany: aSubCollection in: collection = (
	| tmp nTime |
	tmp := collection.
	nTime:= 0.
	[tmp isEmpty ]whileFalse:
		[
		(tmp beginsWith: aSubCollection)
			ifTrue: [
				nTime := nTime + 1.
				1 to: aSubCollection size do: [:i | tmp := tmp allButFirst.]
				]
			ifFalse: [tmp := tmp allButFirst.]
		 ].
	^ nTime.
)

indexInForCollectionWithoutDuplicates = (
	^ 2
)

indexInNonEmpty = (
	^ self nonEmpty size
)

moreThan3Elements = (
	^ collectionWithoutEqualElements
)

moreThan4Elements = (
	^ collectionWithoutEqualElements
)

n = (
	^n
)

n: number = (
	n := number.
)

nextLink = (
	^nextLink
)

nextLink: aLink = (
	nextLink := aLink
)

nonEmpty = (
	^ nonEmpty ifNil: [nonEmpty := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1 with: self element]
)

nonEmpty1Element = (
	^ nonEmpty1Element
)

nonEmptyMoreThan1Element = (
	^collectionWithoutNil
)

nonEmptyWithoutEqualElements = (
	^ collectionWithoutEqualElements
)

numberOfSimilarElementsInIntersection = (
	^ self collection occurrencesOf: self anotherElementOrAssociationIn
)

oldSubCollection = (
	^ self nonEmpty
)

otherCollection = (
	^ otherList ifNil: [otherList := LinkedList with: Link new with: Link new]
)

replacementCollection = (
	^ collectionWithoutNil
)

result = (
	 ^ collectResult
)

setUp = (
	super setUp.
	list := LinkedList new.
	link1 := 133.
	link2 := 'test'.
	link3 := $h.
	link4 := Set new.
	elementNotIn := Link new.
	collectionWithoutNil := LinkedList new add: link1; add: link2 ; add: link3; yourself.
	elementIn := 'thisElementIsIncluded'.
	collectionWithoutEqualElements := LinkedList new add: elementIn ; add: 'pewpew' ; add: 'normal links'; add: 'are no fun!' ;add: $x ;yourself.
	collection5Elements := collectionWithoutEqualElements .
	link := ValueLink value: 42.
	nonEmpty1Element :=  LinkedList new add: Link new; yourself.
)

speciesClass = (
	^LinkedList
)

subCollectionNotIn = (
	^ collectionWithoutNil
)

tearDown = (
	list := nil.
	link1 := nil.
	link2 := nil.
	link3 := nil.
	link4 := nil.
	link := nil.
	nonEmpty := nil.
	otherList := nil.
	^ super tearDown
)

test01add = (
	self assert: list isEmpty.
	list add: link1.
	self assert: list size = 1.
	self assert: list first = link1.
	list add: link2.
	self assert: list size = 2.
	self assert: list first = link1.
	self assert: list second = link2.
	list add: link3.
	self assert: list size = 3.
	self assert: list first = link1.
	self assert: list second = link2.
	self assert: list third = link3.
	list add: link4.
	self assert: list size = 4.
	self assert: list first = link1.
	self assert: list second = link2.
	self assert: list third = link3.
	self assert: list fourth = link4
)

test02addLast = (
	self assert: list isEmpty.
	list addLast: link1.
	self assert: list size = 1.
	self assert: list first = link1.
	list addLast: link2.
	self assert: list size = 2.
	self assert: list first = link1.
	self assert: list second = link2.
	list addLast: link3.
	self assert: list size = 3.
	self assert: list first = link1.
	self assert: list second = link2.
	self assert: list third = link3.
	list addLast: link4.
	self assert: list size = 4.
	self assert: list first = link1.
	self assert: list second = link2.
	self assert: list third = link3.
	self assert: list fourth = link4
)

test03addFirst = (
	self assert: list isEmpty.
	list addFirst: link1.
	self assert: list size = 1.
	self assert: list first = link1.
	list addFirst: link2.
	self assert: list size = 2.
	self assert: list first = link2.
	self assert: list second = link1.
	list addFirst: link3.
	self assert: list size = 3.
	self assert: list first = link3.
	self assert: list second = link2.
	self assert: list third = link1.
	list addFirst: link4.
	self assert: list size = 4.
	self assert: list first = link4.
	self assert: list second = link3.
	self assert: list third = link2.
	self assert: list fourth = link1
)

test04addBefore = (
	self assert: list isEmpty.
	list add: link1.
	self assert: list size = 1.
	self assert: list first == link1.
	list add: link2 before: link1.
	self assert: list size = 2.
	self assert: list first == link2.
	self assert: list second == link1.
	list add: link3 before: link1.
	self assert: list size = 3.
	self assert: list first == link2.
	self assert: list second == link3.
	self assert: list third == link1.
	list add: link4 before: link1.
	self assert: list size = 4.
	self assert: list first == link2.
	self assert: list second == link3.
	self assert: list third == link4.
	self assert: list fourth == link1
)

test05addBefore = (
	self assert: list isEmpty.
	list add: link1.
	self assert: list size = 1.
	self assert: list first == link1.
	list add: link2 before: link1.
	self assert: list size = 2.
	self assert: list first == link2.
	self assert: list second == link1.
	list add: link3 before: link2.
	self assert: list size = 3.
	self assert: list first == link3.
	self assert: list second == link2.
	self assert: list third == link1.
	list add: link4 before: link3.
	self assert: list size = 4.
	self assert: list first == link4.
	self assert: list second == link3.
	self assert: list third == link2.
	self assert: list fourth == link1
)

test06addAfter = (
	self assert: list isEmpty.
	list add: link1.
	self assert: list size = 1.
	self assert: list first == link1.
	list add: link2 after: link1.
	self assert: list size = 2.
	self assert: list first == link1.
	self assert: list second == link2.
	list add: link3 after: link2.
	self assert: list size = 3.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	list add: link4 after: link3.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	self assert: list fourth == link4
)

test07addAfter = (
	self assert: list isEmpty.
	list add: link1.
	self assert: list size = 1.
	self assert: list first == link1.
	list add: link2 after: link1.
	self assert: list size = 2.
	self assert: list first == link1.
	self assert: list second == link2.
	list add: link3 after: link1.
	self assert: list size = 3.
	self assert: list first == link1.
	self assert: list second == link3.
	self assert: list third == link2.
	list add: link4 after: link1.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link4.
	self assert: list third == link3.
	self assert: list fourth == link2
)

test08addAfter = (
	| l first |
	l := LinkedList new.
	first := self class new n: 1.
	l add: first.
	l add: (self class new n: 3).
	self assert: (l collect:[:e | e n]) asArray  = #(1 3).
	l add: (self class new n: 2) after: first.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).
)

test09addAfter = (
	| l last |
	l := LinkedList new.
	last := self class new n: 2.
	l add: (self class new n: 1).
	l add: last.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2).
	l add: (self class new n: 3) after: last.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).
)

test0CopyTest = (
	self empty.
	self assert: self empty size = 0.
	self nonEmpty.
	self assert: (self nonEmpty size = 0) not.
	self collectionWithElementsToRemove.
	self assert: (self collectionWithElementsToRemove size = 0) not.
	self collectionWithElementsToRemove do: [ :each | self assert: (self nonEmpty includes: each) ].
	self elementToAdd.
	self deny: (self nonEmpty includes: self elementToAdd).
	self collectionNotIncluded.
	self collectionNotIncluded do: [ :each | self deny: (self nonEmpty includes: each) ]
)

test0FixtureAsStringCommaAndDelimiterTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self empty.
	self assert: self empty isEmpty.
	self nonEmpty1Element.
	self assert: self nonEmpty1Element size = 1
)

test0FixtureBeginsEndsWithTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self assert: self nonEmpty size > 1.
	self empty.
	self assert: self empty isEmpty
)

test0FixtureCopyPartOfSequenceableTest = (
	self collectionWithoutEqualElements.
	self collectionWithoutEqualElements
		do: [ :each | self assert: (self collectionWithoutEqualElements occurrencesOf: each) = 1 ].
	self indexInForCollectionWithoutDuplicates.
	self
		assert:
			(self indexInForCollectionWithoutDuplicates > 0 and: [ self indexInForCollectionWithoutDuplicates
				< self collectionWithoutEqualElements size ]).
	self empty.
	self assert: self empty isEmpty
)

test0FixtureCopySameContentsTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self empty.
	self assert: self empty isEmpty
)

test0FixtureCopyWithOrWithoutSpecificElementsTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self indexInNonEmpty.
	self assert: self indexInNonEmpty > 0.
	self assert: self indexInNonEmpty <= self nonEmpty size
)

test0FixtureCopyWithReplacementTest = (
	self replacementCollection.
	self oldSubCollection.
	self collectionWith1TimeSubcollection.
	self assert: (self howMany: self oldSubCollection in: self collectionWith1TimeSubcollection) = 1
)

test0FixtureEmptyTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self empty.
	self assert: self empty isEmpty
)

test0FixtureIncludeTest = (
	| anElementIn |
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self elementNotIn.
	anElementIn := true.
	self nonEmpty detect: [ :each | each = self elementNotIn ] ifNone: [ anElementIn := false ].
	self assert: anElementIn = false.
	self anotherElementNotIn.
	anElementIn := true.
	self nonEmpty detect: [ :each | each = self anotherElementNotIn ] ifNone: [ anElementIn := false ].
	self assert: anElementIn = false.
	self empty.
	self assert: self empty isEmpty
)

test0FixtureIncludeWithIdentityTest = (
	| anElement |
	self collectionWithCopyNonIdentical.
	anElement := self collectionWithCopyNonIdentical anyOne.
	self deny: anElement == anElement copy
)

test0FixtureIndexAccessTest = (
	| res |
	self collectionMoreThan1NoDuplicates.
	self assert: self collectionMoreThan1NoDuplicates size = 5.
	res := true.
	self collectionMoreThan1NoDuplicates
		detect: [ :each | (self collectionMoreThan1NoDuplicates occurrencesOf: each) > 1 ]
		ifNone: [ res := false ].
	self assert: res = false.
	self elementInForIndexAccessing.
	self assert: (self collectionMoreThan1NoDuplicates includes: self elementInForIndexAccessing).
	self elementNotInForIndexAccessing.
	self deny: (self collectionMoreThan1NoDuplicates includes: self elementNotInForIndexAccessing)
)

test0FixtureIterateSequencedReadableTest = (
	| res |
	self nonEmptyMoreThan1Element.
	self assert: self nonEmptyMoreThan1Element  size > 1.
	self empty.
	self assert: self empty isEmpty .
	res := true.
	self nonEmptyMoreThan1Element
	detect: [ :each | (self nonEmptyMoreThan1Element    occurrencesOf: each) > 1 ]
	ifNone: [ res := false ].
	self assert: res = false.
)

test0FixtureIterateTest = (
	| res |
	self collectionWithoutNilElements.
	self assert: (self collectionWithoutNilElements occurrencesOf: nil) = 0.
	res := true.
	self collectionWithoutNilElements
		detect: [ :each | (self collectionWithoutNilElements occurrencesOf: each) > 1 ]
		ifNone: [ res := false ].
	self assert: res = false
)

test0FixtureOccurrencesTest = (
	| tmp |
	self empty.
	self assert: self empty isEmpty.
	self collectionWithoutEqualElements.
	self deny: self collectionWithoutEqualElements isEmpty.
	tmp := OrderedCollection new.
	self collectionWithoutEqualElements
		do: [ :each |
			self deny: (tmp includes: each).
			tmp add: each ].
	self elementNotInForOccurrences.
	self deny: (self collectionWithoutEqualElements includes: self elementNotInForOccurrences)
)

test0FixturePrintTest = (
	self nonEmpty.
	self deny: self nonEmpty isEmpty
)

test0FixtureRequirementsOfTAddTest = (
	self collectionWithElement.
	self otherCollection.
	self element.
	self assert: (self collectionWithElement includes: self element).
	self deny: (self otherCollection includes: self element)
)

test0FixtureSequencedElementAccessTest = (
	self moreThan4Elements.
	self assert: self moreThan4Elements size >= 4.
	self subCollectionNotIn.
	self subCollectionNotIn detect: [ :each | (self moreThan4Elements includes: each) not ] ifNone: [ self assert: false ].
	self elementNotInForElementAccessing.
	self deny: (self moreThan4Elements includes: self elementNotInForElementAccessing).
	self elementInForElementAccessing.
	self assert: (self moreThan4Elements includes: self elementInForElementAccessing)
)

test0FixtureSetAritmeticTest = (
	self collection.
	self deny: self collection isEmpty.
	self nonEmpty.
	self deny: self nonEmpty isEmpty.
	self anotherElementOrAssociationNotIn.
	self collection isDictionary
		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]
		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].
	self collectionClass
)

test0FixtureSubcollectionAccessTest = (
	self moreThan3Elements.
	self assert: self moreThan3Elements size > 2
)

test0FixtureTConvertTest = (
	| res |
	self collectionWithoutEqualElements.
	res := true.
	self collectionWithoutEqualElements
		detect: [ :each | (self collectionWithoutEqualElements occurrencesOf: each) > 1 ]
		ifNone: [ res := false ].
	self assert: res = false
)

test0FixtureTRemoveTest = (
	| duplicate |
	self empty.
	self nonEmptyWithoutEqualElements.
	self deny: self nonEmptyWithoutEqualElements isEmpty.
	duplicate := true.
	self nonEmptyWithoutEqualElements
		detect: [ :each | (self nonEmptyWithoutEqualElements occurrencesOf: each) > 1 ]
		ifNone: [ duplicate := false ].
	self assert: duplicate = false.
	self elementNotIn.
	self assert: self empty isEmpty.
	self deny: self nonEmptyWithoutEqualElements isEmpty.
	self deny: (self nonEmptyWithoutEqualElements includes: self elementNotIn)
)

test0TStructuralEqualityTest = (
	self empty.
	self nonEmpty.
	self assert: self empty isEmpty.
	self deny: self nonEmpty isEmpty
)

test10removeFirst = (
	list add: link1.
	list add: link2.
	list add: link3.
	list add: link4.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	self assert: list fourth == link4.
	list removeFirst.
	self assert: list size = 3.
	self assert: list first == link2.
	self assert: list second == link3.
	self assert: list third == link4.
	list removeFirst.
	self assert: list size = 2.
	self assert: list first == link3.
	self assert: list second == link4.
	list removeFirst.
	self assert: list size = 1.
	self assert: list first == link4.
	list removeFirst.
	self assert: list isEmpty
)

test11removeLast = (
	list add: link1.
	list add: link2.
	list add: link3.
	list add: link4.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	self assert: list fourth == link4.
	list removeLast.
	self assert: list size = 3.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	list removeLast.
	self assert: list size = 2.
	self assert: list first == link1.
	self assert: list second == link2.
	list removeLast.
	self assert: list size = 1.
	self assert: list first == link1.
	list removeFirst.
	self assert: list isEmpty
)

test12remove = (
	list add: link1.
	list add: link2.
	list add: link3.
	list add: link4.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	self assert: list fourth == link4.
	list remove: link3.
	self assert: list size = 3.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link4.
	list remove: link2.
	self assert: list size = 2.
	self assert: list first == link1.
	self assert: list second == link4.
	list remove: link1.
	self assert: list size = 1.
	self assert: list first == link4.
	list remove: link4.
	self assert: list isEmpty
)

test13remove = (
	list add: link1.
	list add: link2.
	list add: link3.
	list add: link4.
	self assert: list size = 4.
	self assert: list first == link1.
	self assert: list second == link2.
	self assert: list third == link3.
	self assert: list fourth == link4.
	list remove: link1.
	self assert: list size = 3.
	self assert: list first == link2.
	self assert: list second == link3.
	self assert: list third == link4.
	list remove: link4.
	self assert: list size = 2.
	self assert: list first == link2.
	self assert: list second == link3.
	list remove: link2.
	self assert: list size = 1.
	self assert: list first == link3.
	list remove: link3.
	self assert: list isEmpty
)

test14removeIfAbsent = (
	list add: link1.
	self assert: list size = 1.
	self assert: list first == link1.
	list remove: link1.
	self assert: list isEmpty.
	[list remove: link1]
		on: Error
		do: [^ self].
	self assert: false
)

test22addAll = (
	| link5 link6 link7 link8 listToBeAdded |
	link5 := Link new.
	link6 := Link new.
	link7 := Link new.
	link8 := Link new.
	list
		add: link1;
		add: link2;
		add: link3;
		add: link4.
	listToBeAdded := LinkedList new.
	listToBeAdded
		add: link5;
		add: link6;
		add: link7;
		add: link8.
	list addAll: listToBeAdded.
	self should: [(list at: 1) == link1].
	self should: [(list at: 2) == link2].
	self should: [(list at: 3) == link3].
	self should: [(list at: 4) == link4].
	self should: [(list at: 5) == link5].
	self should: [(list at: 6) == link6].
	self should: [(list at: 7) == link7].
	self should: [(list at: 8) == link8].
)

testAddAfter = (
	| l first |
	l := LinkedList new.
	first := self class new n: 1.
	l add: first.
	l add: (self class new n: 3).
	self assert: (l collect:[:e | e n]) asArray  = #(1 3).
	l add: (self class new n: 2) after: first.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).
)

testAddAfterLast = (
	| l last |
	l := LinkedList new.
	last := self class new n: 2.
	l add: (self class new n: 1).
	l add: last.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2).
	l add: (self class new n: 3) after: last.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).
)

testAddAfterLast2 = (
	| l first second third fourth |
	l := LinkedList new.
	first := self class new n: 1.
	second := self class new n: 2.
	third := self class new n: 3.
	fourth :=self class new n: 4.
	l addLast: first.
	l addLast: second.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2).
	l add: third after: second.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).
	l addLast: fourth.
	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3 4).
)

testAfter = (
	self assert: (self moreThan4Elements after: (self moreThan4Elements at: 1)) = (self moreThan4Elements at: 2).
	self
		should:
			[ self moreThan4Elements after: (self moreThan4Elements at: self moreThan4Elements size) ]
		raise: Error.
	self
		should: [ self moreThan4Elements after: self elementNotInForElementAccessing ]
		raise: Error
)

testAfterIfAbsent = (
	self assert: (self moreThan4Elements
			after: (self moreThan4Elements at: 1)
			ifAbsent: [ 33 ]) = (self moreThan4Elements at: 2).
	self assert: (self moreThan4Elements
			after: (self moreThan4Elements at: self moreThan4Elements size)
			ifAbsent: [ 33 ]) = 33.
	self assert: (self moreThan4Elements
			after: self elementNotInForElementAccessing
			ifAbsent: [ 33 ]) = 33
)

testAllButFirst = (
	| abf col |
	col := self moreThan3Elements.
	abf := col allButFirst.
	self deny: abf first = col first.
	self assert: abf size + 1 = col size
)

testAllButFirstDo = (
	| result |
	result:= OrderedCollection  new.
	self nonEmptyMoreThan1Element  allButFirstDo: [:each | result add: each].
	1 to: (result size) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:(i +1))=(result at:i)].
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
)

testAllButFirstNElements = (
	| abf col |
	col := self moreThan3Elements.
	abf := col allButFirst: 2.
	1
		to: abf size
		do: [ :i | self assert: (abf at: i) = (col at: i + 2) ].
	self assert: abf size + 2 = col size
)

testAllButLast = (
	| abf col |
	col := self moreThan3Elements.
	abf := col allButLast.
	self deny: abf last = col last.
	self assert: abf size + 1 = col size
)

testAllButLastDo = (
	| result |
	result:= OrderedCollection  new.
	self nonEmptyMoreThan1Element  allButLastDo: [:each | result add: each].
	1 to: (result size) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:(i ))=(result at:i)].
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
)

testAllButLastNElements = (
	| abf col |
	col := self moreThan3Elements.
	abf := col allButLast: 2.
	1
		to: abf size
		do: [ :i | self assert: (abf at: i) = (col at: i) ].
	self assert: abf size + 2 = col size
)

testAllSatisfy = (
	| element |
	self assert: ( self collectionWithoutNilElements  allSatisfy: [:each | (each notNil) ] ).
	self deny: ( self collectionWithoutNilElements  allSatisfy: [:each | (each notNil) not ] ).
	element := self collectionWithoutNilElements anyOne.
	self deny: ( self collectionWithoutNilElements  allSatisfy: [:each | (each = element) not] ).
)

testAllSatisfyEmpty = (
	self assert: ( self empty allSatisfy: [:each | false]).
)

testAnySastify = (
	| element |
	self assert: ( self collectionWithoutNilElements anySatisfy: [:each | each notNil ]).
	element := self collectionWithoutNilElements anyOne.
	self assert: ( self collectionWithoutNilElements  anySatisfy: [:each | (each = element)  ]   ).
	self deny: ( self collectionWithoutNilElements anySatisfy: [:each | (each notNil) not ]).
)

testAsArray = (
	self
		assertSameContents: self collectionWithoutEqualElements
		whenConvertedTo: Array
)

testAsBag = (
	self assertSameContents: self collectionWithoutEqualElements whenConvertedTo: Bag
)

testAsIdentitySet = (
	self
		assertSameContents: self collectionWithoutEqualElements
		whenConvertedTo: IdentitySet.
)

testAsOrderedCollection = (
	self assertSameContents: self collectionWithoutEqualElements whenConvertedTo: OrderedCollection
)

testAsSet = (
	self assertSameContents: self collectionWithoutEqualElements whenConvertedTo: Set.
)

testAt = (
	| index |
	index := self moreThan4Elements indexOf: self elementInForElementAccessing.
	self assert: (self moreThan4Elements at: index) = self elementInForElementAccessing
)

testAtAll = (
	| result |
	result := self moreThan4Elements atAll: #(2 1 2 ).
	self assert: (result at: 1) = (self moreThan4Elements at: 2).
	self assert: (result at: 2) = (self moreThan4Elements at: 1).
	self assert: (result at: 3) = (self moreThan4Elements at: 2).
	self assert: (self moreThan4Elements atAll: #()) = self moreThan4Elements species new
)

testAtIfAbsent = (
	| absent |
	absent := false.
	self moreThan4Elements
		at: self moreThan4Elements size + 1
		ifAbsent: [ absent := true ].
	self assert: absent = true.
	absent := false.
	self moreThan4Elements
		at: self moreThan4Elements size
		ifAbsent: [ absent := true ].
	self assert: absent = false
)

testAtLast = (
	| index |
	self assert: (self moreThan4Elements atLast: 1) = self moreThan4Elements last.
	index := self moreThan4Elements indexOf: self elementInForElementAccessing.
	self assert: (self moreThan4Elements atLast: index) = (self moreThan4Elements at: self moreThan4Elements size - index + 1)
)

testAtLastError = (
	self
		should: [ self moreThan4Elements atLast: self moreThan4Elements size + 1 ]
		raise: Error
)

testAtLastIfAbsent = (
	self assert: (self moreThan4Elements
			atLast: 1
			ifAbsent: [ nil ]) = self moreThan4Elements last.
	self assert: (self moreThan4Elements
			atLast: self moreThan4Elements size + 1
			ifAbsent: [ 222 ]) = 222
)

testAtOutOfBounds = (
	self
		should: [ self moreThan4Elements at: self moreThan4Elements size + 1 ]
		raise: Error.
	self
		should: [ self moreThan4Elements at: -1 ]
		raise: Error
)

testAtPin = (
	self assert: (self moreThan4Elements atPin: 2) = self moreThan4Elements second.
	self assert: (self moreThan4Elements atPin: 99) = self moreThan4Elements last.
	self assert: (self moreThan4Elements atPin: -99) = self moreThan4Elements first
)

testAtPut = (
	| ll |
	ll := LinkedList new.
	ll add: 1.
	ll at: 1 put: 2.
	self assert: (ll at: 1) equals: 2
)

testAtPutOutsideBounds = (
	| ll |
	ll := LinkedList new.
	self should: [ ll at: 1 put: 1 ] raise: Error
)

testAtRandom = (
	| result |
	result := self nonEmpty atRandom .
	self assert: (self nonEmpty includes: result).
)

testAtWrap = (
	| index |
	index := self moreThan4Elements indexOf: self elementInForElementAccessing.
	self assert: (self moreThan4Elements atWrap: index) = self elementInForElementAccessing.
	self assert: (self moreThan4Elements atWrap: index + self moreThan4Elements size) = self elementInForElementAccessing.
	self assert: (self moreThan4Elements atWrap: index - self moreThan4Elements size) = self elementInForElementAccessing.
	self assert: (self moreThan4Elements atWrap: 1 + self moreThan4Elements size) = (self moreThan4Elements at: 1)
)

testBasicCollect = (
	| res index |
	index := 0.
	res := self collectionWithoutNilElements collect: [ :each |
		index := index + 1.
		each ].
	res do: [ :each |
		self assert: (self collectionWithoutNilElements occurrencesOf: each) = (res occurrencesOf: each)].
	self assert: index equals: self collectionWithoutNilElements size.
)

testBasicCollectEmpty = (
	| res |
	res := self empty collect: [:each | each class].
	self assert: res isEmpty
)

testBefore = (
	self assert: (self moreThan4Elements before: (self moreThan4Elements at: 2)) = (self moreThan4Elements at: 1).
	self
		should: [ self moreThan4Elements before: (self moreThan4Elements at: 1) ]
		raise: Error.
	self
		should: [ self moreThan4Elements before: 66 ]
		raise: Error
)

testBeforeIfAbsent = (
	self assert: (self moreThan4Elements
			before: (self moreThan4Elements at: 1)
			ifAbsent: [ 99 ]) = 99.
	self assert: (self moreThan4Elements
			before: (self moreThan4Elements at: 2)
			ifAbsent: [ 99 ]) = (self moreThan4Elements at: 1)
)

testCollectFromTo = (
	| result |
	result:=self nonEmptyMoreThan1Element
		collect: [ :each | each ]
		from: 1
		to: (self nonEmptyMoreThan1Element size - 1).
	1 to: result size
		do: [ :i | self assert: (self nonEmptyMoreThan1Element at: i) = (result at: i) ].
	self assert: result size = (self nonEmptyMoreThan1Element size - 1)
)

testCollectOnEmpty = (
	self assert: (self empty collect: [:e | self fail]) isEmpty
)

testCollectThenDoOnEmpty = (
	self assert: (self empty collect: [:e | self fail] thenDo: [ self fail ]) isEmpty
)

testCollectThenSelectOnEmpty = (
	self assert: (self empty collect: [:e | self fail] thenSelect: [:e | self fail ]) isEmpty
)

testCopyAfter = (
	| result index collection |
	collection := self collectionWithoutEqualElements .
	index:= self indexInForCollectionWithoutDuplicates .
	result := collection   copyAfter: (collection  at:index ).
	(1) to: result size do:
		[:i |
		self assert: (collection   at:(i + index ))=(result at: (i))].
	self assert: result size = (collection   size - index).
)

testCopyAfterEmpty = (
	| result |
	result := self empty copyAfter: self collectionWithoutEqualElements first.
	self assert: result isEmpty.
)

testCopyAfterLast = (
	| result index collection |
	collection := self collectionWithoutEqualElements .
	index:= self indexInForCollectionWithoutDuplicates .
	result := collection   copyAfterLast: (collection  at:index ).
	(1) to: result size do:
		[:i |
		self assert: (collection   at:(i + index ))=(result at: (i))].
	self assert: result size = (collection   size - index).
)

testCopyAfterLastEmpty = (
	| result |
	result := self empty copyAfterLast: self collectionWithoutEqualElements first.
	self assert: result isEmpty.
)

testCopyEmptyWith = (
	| res anElement |
	anElement := self elementToAdd.
	res := self empty copyWith: anElement.
	self assert: res size = (self empty size + 1).
	self assert: (res includes: (anElement value))
)

testCopyEmptyWithout = (
	| res |
	res := self empty copyWithout: self elementToAdd.
	self assert: res size = self empty size.
	self deny: (res includes: self elementToAdd)
)

testCopyEmptyWithoutAll = (
	| res |
	res := self empty copyWithoutAll: self collectionWithElementsToRemove.
	self assert: res size = self empty size.
	self collectionWithElementsToRemove do: [ :each | self deny: (res includes: each) ]
)

testCopyEquals = (
	| copy |
	copy := self nonEmpty copy.
	self assert: copy  = self nonEmpty.
)

testCopyFromTo = (
	| result  index collection |
	collection := self collectionWithoutEqualElements .
	index :=self indexInForCollectionWithoutDuplicates .
	result := collection   copyFrom: index  to: collection  size .
	1 to: result size do:
		[:i |
		self assert: (result at:i)=(collection  at: (i + index - 1))].
	self assert: result size = (collection  size - index + 1).
)

testCopyNonEmptyWith = (
	| res anElement |
	anElement := self elementToAdd .
	res := self nonEmpty copyWith: anElement.
	self assert: (res includes: (anElement value)).
	self nonEmpty do: [ :each | res includes: each ]
)

testCopyNonEmptyWithout = (
	| res anElementOfTheCollection |
	anElementOfTheCollection :=  self nonEmpty anyOne.
	res := (self nonEmpty copyWithout: anElementOfTheCollection).
	self deny: (res includes: anElementOfTheCollection).
	self nonEmpty do:
		[:each | (each = anElementOfTheCollection)
					ifFalse: [self assert: (res includes: each)]].
)

testCopyNonEmptyWithoutAll = (
	| res |
	res := self nonEmpty copyWithoutAll: self collectionWithElementsToRemove.
	self collectionWithElementsToRemove do: [ :each | self deny: (res includes: (each)) ].
	self nonEmpty do:
		[ :each |
		(self collectionWithElementsToRemove includes: each) ifFalse: [ self assert: (res includes: each) ] ]
)

testCopyNonEmptyWithoutAllNotIncluded = (
	| res |
	res := self nonEmpty copyWithoutAll: self collectionNotIncluded.
	self nonEmpty do: [ :each | self assert: (res includes: each) ]
)

testCopyNonEmptyWithoutNotIncluded = (
	| res |
	res := self nonEmpty copyWithout: self elementToAdd.
	self nonEmpty do: [ :each | self assert: (res includes: each) ]
)

testCopyNotSame = (
	| copy |
	copy := self nonEmpty copy.
	self deny: copy  == self nonEmpty.
)

testCopyReplaceAllWith1Occurence = (
	| result  firstIndexesOfOccurrence index endPartIndexResult endPartIndexCollection |
	result := self collectionWith1TimeSubcollection  copyReplaceAll: self oldSubCollection with: self replacementCollection .
	firstIndexesOfOccurrence  := self firstIndexesOf: self oldSubCollection in: self collectionWith1TimeSubcollection .
	index:= firstIndexesOfOccurrence at: 1.
	1 to: (index -1) do:
		[
		:i |
		self assert: (self collectionWith1TimeSubcollection  at:i)=(result at: i)
		].
	index to: (index + self replacementCollection size-1) do:
		[
		:i |
		self assert: ( result at: i )=(self replacementCollection at: ( i - index + 1 ))
		].
	endPartIndexResult :=  index + self replacementCollection  size .
	endPartIndexCollection :=   index + self oldSubCollection size  .
	1 to: (result size - endPartIndexResult - 1 ) do:
		[
		:i |
		self assert: (result at: ( endPartIndexResult + i - 1 ) ) = (self collectionWith1TimeSubcollection  at: ( endPartIndexCollection + i - 1 ) ).
		].
)

testCopyReplaceFromToWith = (
	| result  indexOfSubcollection lastIndexOfOldSubcollection lastIndexOfReplacementCollection |
	indexOfSubcollection := (self firstIndexesOf: self oldSubCollection  in:  self collectionWith1TimeSubcollection) at: 1.
	lastIndexOfOldSubcollection := indexOfSubcollection + self oldSubCollection size -1.
	lastIndexOfReplacementCollection := indexOfSubcollection + self replacementCollection  size -1.
	result := self collectionWith1TimeSubcollection  copyReplaceFrom: indexOfSubcollection  to: lastIndexOfOldSubcollection   with: self replacementCollection .
	1 to: (indexOfSubcollection  - 1) do:
		[
		:i |
		self assert: (self collectionWith1TimeSubcollection  at:i) = (result at: i)
		].
	(indexOfSubcollection ) to: ( lastIndexOfReplacementCollection  ) do:
		[
		:i |
		self assert: (result at: i)=(self replacementCollection at: (i - indexOfSubcollection +1))
		].
	1 to: (result size - lastIndexOfReplacementCollection   ) do:
		[
		:i |
		self assert: (result at: ( lastIndexOfReplacementCollection  + i  ) ) = (self collectionWith1TimeSubcollection  at: ( lastIndexOfOldSubcollection  + i  ) ).
		].
)

testCopyReplaceFromToWithInsertion = (
	| result  indexOfSubcollection |
	indexOfSubcollection := (self firstIndexesOf: self oldSubCollection  in:  self collectionWith1TimeSubcollection) at: 1.
	result := self collectionWith1TimeSubcollection  copyReplaceFrom: indexOfSubcollection  to: ( indexOfSubcollection - 1 ) with: self replacementCollection .
	1 to: (indexOfSubcollection -1) do:
		[
		:i |
		self assert: (self collectionWith1TimeSubcollection  at:i)=(result at: i)
		].
	indexOfSubcollection  to: (indexOfSubcollection  + self replacementCollection size-1) do:
		[
		:i |
		self assert: ( result at: i )=(self replacementCollection at: ( i - indexOfSubcollection +1 ))
		].
	(indexOfSubcollection  + self replacementCollection size) to: (result size) do:
		[:i|
		self assert: (result at: i)=(self collectionWith1TimeSubcollection  at: (i-self replacementCollection size))].
	self assert: result size=(self collectionWith1TimeSubcollection  size + self replacementCollection size).
)

testCopySameClass = (
	| copy |
	copy := self empty copy.
	self assert: copy class == self empty class.
)

testCopyUpTo = (
	| result index collection |
	collection := self collectionWithoutEqualElements .
	index:= self indexInForCollectionWithoutDuplicates .
	result := collection   copyUpTo: (collection  at:index).
	1 to: result size do: [:i| self assert: (collection   at:i)=(result at:i)].
	self assert: result size = (index-1).
)

testCopyUpToEmpty = (
	| result |
	result := self empty copyUpTo: self collectionWithoutEqualElements first.
	self assert: result isEmpty.
)

testCopyUpToLast = (
	| result index collection |
	collection := self collectionWithoutEqualElements .
	index:= self indexInForCollectionWithoutDuplicates .
	result := collection   copyUpToLast: (collection  at:index).
	1 to: result size do: [:i| self assert: (collection   at:i)=(result at:i)].
	self assert: result size = (index-1).
)

testCopyUpToLastEmpty = (
	| result |
	result := self empty copyUpToLast: self collectionWithoutEqualElements first.
	self assert: result isEmpty.
)

testCopyWithFirst = (
	| index element result |
	index:= self indexInNonEmpty .
	element:= self nonEmpty at: index.
	result := self nonEmpty copyWithFirst: element.
	self assert: result size = (self nonEmpty size + 1).
	self assert: result first = element .
	2 to: result size do:
	[ :i |
	self assert: (result at: i) = ( self nonEmpty at: ( i - 1 ))].
)

testCopyWithSequenceable = (
	| result index element |
	index := self indexInNonEmpty .
	element := self nonEmpty at: index.
	result := self nonEmpty copyWith: (element ).
	self assert: result size = (self nonEmpty size + 1).
	self assert: result last = element .
	1 to: (result size - 1) do:
	[ :i |
	self assert: (result at: i) = ( self nonEmpty at: ( i  ))].
)

testCopyWithoutFirst = (
	| result |
	result := self nonEmpty allButFirst.
	self assert: result size = (self nonEmpty size - 1).
	1 to: result size do:
		[:i |
		self assert: (result at: i)= (self nonEmpty at: (i + 1))].
)

testCopyWithoutIndex = (
	| result index |
	index := self indexInNonEmpty .
	result := self nonEmpty copyWithoutIndex: index .
	1 to: result size do:
		[:i |
		i<( index ) ifTrue: [self assert: ((result at:i )= (self nonEmpty at:i))].
		i>=( index ) ifTrue: [self assert: (result at:i )= (self nonEmpty at:(i+1))]].
	self assert: result size=(self nonEmpty size -1).
)

testCreateAs = (
	| anotherCollection aLinkedList |
	anotherCollection := 1 to: 10.
	aLinkedList := anotherCollection as: LinkedList.
	self assert: (aLinkedList isMemberOf: LinkedList).
	self assert: aLinkedList size equals: anotherCollection size.
	aLinkedList with: anotherCollection do: [:nextElementOfLinkedList :nextElementOfAnotherCollection |
		self assert: nextElementOfLinkedList equals: nextElementOfAnotherCollection]
)

testDetect = (
	| res element |
	element := self collectionWithoutNilElements anyOne .
	res := self collectionWithoutNilElements  detect: [:each | each = element].
	self assert: (res  = element).
)

testDetectIfNone = (
	| res element |
	res := self collectionWithoutNilElements  detect: [:each | each notNil not] ifNone: [100].
	self assert: res  = 100.
	element := self collectionWithoutNilElements anyOne.
	res := self collectionWithoutNilElements  detect: [:each | each = element] ifNone: [100].
	self assert: res  = element.
)

testDetectSequenced = (
	| element result |
	element := self nonEmptyMoreThan1Element   at:1.
	result:=self nonEmptyMoreThan1Element  detect: [:each | each notNil ].
	self assert: result = element.
)

testDifference = (
	| difference |
	self assert: (self collectionWithoutEqualElements difference: self collectionWithoutEqualElements) isEmpty.
	self assert: (self empty difference: self collectionWithoutEqualElements) isEmpty.
	difference := (self collectionWithoutEqualElements difference: self empty).
	self assert: difference size = self collectionWithoutEqualElements	 size.
	self collectionWithoutEqualElements do: [ :each |
		self assert: (difference includes: each)].
)

testDifferenceWithNonNullIntersection = (
	| res overlapping |
	overlapping := self collectionClass
		with: self anotherElementOrAssociationNotIn
		with: self anotherElementOrAssociationIn.
	res := self collection difference: overlapping.
	self deny: (res includes: self anotherElementOrAssociationIn).
	overlapping do: [ :each | self deny: (res includes: each) ]
)

testDifferenceWithSeparateCollection = (
	| res separateCol |
	separateCol := self collectionClass with: self anotherElementOrAssociationNotIn.
	res := self collectionWithoutEqualElements difference: separateCol.
	self deny: (res includes: self anotherElementOrAssociationNotIn).
	self assert: res size equals: self collectionWithoutEqualElements size.
	self collectionWithoutEqualElements do: [ :each|
		self assert: (res includes: each)].
	res := separateCol difference: self collection.
	self deny: (res includes: self collection anyOne).
	self assert: res equals: separateCol
)

testDo = (
)

testDo2 = (
	| collection cptElementsViewed cptElementsIn |
	collection := self collectionWithoutNilElements.
	cptElementsViewed := 0.
	cptElementsIn := OrderedCollection new.
	collection do:
		[ :each |
		cptElementsViewed := cptElementsViewed + 1.
		(collection includes: each) ifTrue: [
			( cptElementsIn includes: each ) ifFalse: [ cptElementsIn add: each ] .
			].
		].
	self assert: cptElementsViewed = collection size.
	self assert: cptElementsIn size  = collection size.
)

testDoSeparatedBy = (
	| string expectedString beforeFirst |
	string := ''.
	self collectionWithoutNilElements
		do: [ :each | string := string , each asString ]
		separatedBy: [ string := string , '|' ].
	expectedString := ''.
	beforeFirst := true.
	self collectionWithoutNilElements  do:
		[ :each |
		beforeFirst = true
			ifTrue: [ beforeFirst := false ]
			ifFalse: [ expectedString := expectedString , '|' ].
		expectedString := expectedString , each asString ].
	self assert: expectedString = string
)

testDoWithout = (
	| res element collection |
	collection := self collectionWithoutNilElements .
	res := OrderedCollection new.
	element := self collectionWithoutNilElements anyOne .
	collection  do: [:each | res add: each] without: element  .
	self assert: res size = (collection  size - (collection  occurrencesOf: element)).
	res do: [:each | self assert: (collection occurrencesOf: each) = ( res occurrencesOf: each ) ].
)

testEqualSign = (
	self deny: (self empty = self nonEmpty).
)

testEqualSignIsTrueForNonIdenticalButEqualCollections = (
	self assert: (self empty = self empty copy).
	self assert: (self empty copy = self empty).
	self assert: (self empty copy = self empty copy).
	self assert: (self nonEmpty = self nonEmpty copy).
	self assert: (self nonEmpty copy = self nonEmpty).
	self assert: (self nonEmpty copy = self nonEmpty copy).
)

testEqualSignOfIdenticalCollectionObjects = (
	self assert: (self empty = self empty).
	self assert: (self nonEmpty = self nonEmpty).
)

testFindFirst = (
	| element result |
	element := self nonEmptyMoreThan1Element   at:1.
	 result:=self nonEmptyMoreThan1Element  findFirst: [:each | each =element].
	self assert: result=1.
)

testFindFirstNotIn = (
	| result |
	 result:=self empty findFirst: [:each | true].
	self assert: result=0.
)

testFindLast = (
	| element result |
	element := self nonEmptyMoreThan1Element  at:self nonEmptyMoreThan1Element  size.
	 result:=self nonEmptyMoreThan1Element  findLast: [:each | each =element].
	self assert: result=self nonEmptyMoreThan1Element  size.
)

testFindLastNotIn = (
	| result |
	 result:=self empty findFirst: [:each | true].
	self assert: result=0.
)

testFirstNElements = (
	| result |
	result := self moreThan3Elements first: self moreThan3Elements size - 1.
	1
		to: result size
		do: [ :i | self assert: (result at: i) = (self moreThan3Elements at: i) ].
	self assert: result size = (self moreThan3Elements size - 1).
	self
		should: [ self moreThan3Elements first: self moreThan3Elements size + 1 ]
		raise: Error
)

testFirstSecondThird = (
	self assert: self moreThan4Elements first = (self moreThan4Elements at: 1).
	self assert: self moreThan4Elements second = (self moreThan4Elements at: 2).
	self assert: self moreThan4Elements third = (self moreThan4Elements at: 3).
	self assert: self moreThan4Elements fourth = (self moreThan4Elements at: 4)
)

testForceToPaddingStartWith = (
	| result element |
	element := self nonEmpty at: self indexInNonEmpty .
	result := self nonEmpty forceTo: (self nonEmpty size+2) paddingStartWith: ( element ).
	1 to: 2   do:
		[:i | self assert: ( element ) = ( result at:(i) ) ].
	3 to: result size do:
		[:i | self assert: ( result at:i ) = ( self nonEmpty at:(i-2) ) ].
	self assert: result size = (self nonEmpty size + 2).
)

testForceToPaddingWith = (
	| result element |
	element := self nonEmpty at: self indexInNonEmpty .
	result := self nonEmpty forceTo: (self nonEmpty size+2) paddingWith: ( element ).
	1 to: self nonEmpty  size do:
		[:i | self assert: ( self nonEmpty at: i ) = ( result at:(i) ). ].
	(result size - 1) to: result size do:
		[:i | self assert: ( result at:i ) = ( element ) ].
	self assert: result size = (self nonEmpty size + 2).
)

testFromToDo = (
	| result |
	result:= OrderedCollection  new.
	self nonEmptyMoreThan1Element  from: 1 to: (self nonEmptyMoreThan1Element  size -1) do: [:each | result add: each].
	1 to: (self nonEmptyMoreThan1Element  size -1) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:i )=(result at:i)].
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
)

testIdentityIncludes = (
	| collection element |
	self collectionWithCopyNonIdentical.
	collection := self collectionWithCopyNonIdentical.
	element := collection anyOne copy.
	self deny: (collection identityIncludes: element)
)

testIdentityIncludesNonSpecificComportement = (
	| collection |
	collection := self nonEmpty  .
	self deny: (collection identityIncludes: self elementNotIn ).
	self assert:(collection identityIncludes: collection anyOne)
)

testIdentityIndexOf = (
	| collection element |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection identityIndexOf: element) = (collection indexOf: element)
)

testIdentityIndexOfIAbsent = (
	| collection element |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection
			identityIndexOf: element
			ifAbsent: [ 0 ]) = 1.
	self assert: (collection
			identityIndexOf: self elementNotInForIndexAccessing
			ifAbsent: [ 55 ]) = 55
)

testIfEmpty = (
	self nonEmpty ifEmpty: [ self assert: false] .
	self empty ifEmpty: [ self assert: true] .
)

testIfEmptyifNotEmpty = (
	self assert: (self empty ifEmpty: [true] ifNotEmpty: [false]).
	self assert: (self nonEmpty ifEmpty: [false] ifNotEmpty: [true]).
)

testIfNotEmpty = (
	self empty ifNotEmpty: [self assert: false].
	self nonEmpty ifNotEmpty: [self assert: true].
	self assert: (self nonEmpty ifNotEmpty: [:s | s ]) = self nonEmpty
)

testIfNotEmptyifEmpty = (
	self assert: (self empty ifNotEmpty: [false] ifEmpty: [true]).
	self assert: (self nonEmpty ifNotEmpty: [true] ifEmpty: [false]).
)

testIncludesAllNoneThere = (
	self deny: (self empty includesAllOf: self nonEmpty ).
	self deny: (self nonEmpty includesAllOf: { self elementNotIn. self anotherElementNotIn })
)

testIncludesAnyAllThere = (
	self deny: (self nonEmpty includesAnyOf: self empty).
	self assert: (self nonEmpty includesAnyOf: { self nonEmpty anyOne }).
	self assert: (self nonEmpty includesAnyOf: self nonEmpty).
)

testIncludesAnyNoneThere = (
	self deny: (self nonEmpty includesAnyOf: self empty).
	self deny: (self nonEmpty includesAnyOf: { self elementNotIn. self anotherElementNotIn })
)

testIncludesElementIsNotThere = (
	self deny: (self nonEmpty includes: self elementNotIn).
	self assert: (self nonEmpty includes: self nonEmpty anyOne).
	self deny: (self empty includes: self elementNotIn)
)

testIncludesElementIsThere = (
	self assert: (self nonEmpty includes: self nonEmpty anyOne).
)

testIndexOf = (
	| tmp index collection |
	collection := self collectionMoreThan1NoDuplicates.
	tmp := collection size.
	collection reverseDo:
		[ :each |
		each = self elementInForIndexAccessing ifTrue: [ index := tmp ].
		tmp := tmp - 1 ].
	self assert: (collection indexOf: self elementInForIndexAccessing) = index
)

testIndexOfIfAbsent = (
	| collection |
	collection := self collectionMoreThan1NoDuplicates.
	self assert: (collection
			indexOf: collection first
			ifAbsent: [ 33 ]) = 1.
	self assert: (collection
			indexOf: self elementNotInForIndexAccessing
			ifAbsent: [ 33 ]) = 33
)

testIndexOfStartingAt = (
	| element collection |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection
			indexOf: element
			startingAt: 2
			ifAbsent: [ 99 ]) = 99.
	self assert: (collection
			indexOf: element
			startingAt: 1
			ifAbsent: [ 99 ]) = 1.
	self assert: (collection
			indexOf: self elementNotInForIndexAccessing
			startingAt: 1
			ifAbsent: [ 99 ]) = 99
)

testIndexOfStartingAtIfAbsent = (
	| element collection |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection
			indexOf: element
			startingAt: 2
			ifAbsent: [ 99 ]) = 99.
	self assert: (collection
			indexOf: element
			startingAt: 1
			ifAbsent: [ 99 ]) = 1.
	self assert: (collection
			indexOf: self elementNotInForIndexAccessing
			startingAt: 1
			ifAbsent: [ 99 ]) = 99
)

testIndexOfSubCollectionStartingAt = (
	| subcollection index collection |
	collection := self collectionMoreThan1NoDuplicates.
	subcollection := self collectionMoreThan1NoDuplicates.
	index := collection
		indexOfSubCollection: subcollection
		startingAt: 1.
	self assert: index = 1.
	index := collection
		indexOfSubCollection: subcollection
		startingAt: 2.
	self assert: index = 0
)

testIndexOfSubCollectionStartingAtIfAbsent = (
	| index absent subcollection collection |
	collection := self collectionMoreThan1NoDuplicates.
	subcollection := self collectionMoreThan1NoDuplicates.
	absent := false.
	index := collection
		indexOfSubCollection: subcollection
		startingAt: 1
		ifAbsent: [ absent := true ].
	self assert: absent = false.
	absent := false.
	index := collection
		indexOfSubCollection: subcollection
		startingAt: 2
		ifAbsent: [ absent := true ].
	self assert: absent = true
)

testInjectInto = (
	|result|
	result:= self collectionWithoutNilElements
		inject: 0
		into: [:inj :ele | ele notNil ifTrue: [ inj + 1 ]].
	self assert: self collectionWithoutNilElements size = result .
)

testIntersectionBasic = (
	| inter |
	inter := self collection intersection: (self collectionClass with: self anotherElementOrAssociationIn).
	self deny: inter isEmpty.
	self assert: (inter includes: self anotherElementOrAssociationIn value)
)

testIntersectionEmpty = (
	| inter |
	inter := self empty intersection: self empty.
	self assert: inter isEmpty.
	inter := self empty intersection: self collection .
	self assert: inter =  self empty.
)

testIntersectionItself = (
	| result |
	result :=  (self collectionWithoutEqualElements intersection: self collectionWithoutEqualElements).
	self assert: result size  = self collectionWithoutEqualElements size.
	self collectionWithoutEqualElements do: [ :each|
		self assert: (result includes: each) ].
)

testIntersectionTwoSimilarElementsInIntersection = (
	| inter |
	inter := self collection intersection: (self collectionClass with: self anotherElementOrAssociationIn).
	self assert: (self collection occurrencesOf: self anotherElementOrAssociationIn) = self numberOfSimilarElementsInIntersection.
	self assert: (inter includes: self anotherElementOrAssociationIn value)
)

testIsEmpty = (
	self assert: (self empty isEmpty).
	self deny: (self nonEmpty isEmpty).
)

testIsEmptyOrNil = (
	self assert: (self empty isEmptyOrNil).
	self deny: (self nonEmpty isEmptyOrNil).
)

testKeysAndValuesDo = (
	|  indexes elements |
	indexes:= OrderedCollection new.
	elements := OrderedCollection new.
	self nonEmptyMoreThan1Element  keysAndValuesDo:
		[:i :value|
		indexes  add: (i).
		elements add: value].
	(1 to: self nonEmptyMoreThan1Element size )do:
		[ :i |
		self assert: (indexes at: i) = i.
		self assert: (elements at: i) = (self nonEmptyMoreThan1Element at: i).
		].
	self assert: indexes size = elements size.
	self assert: indexes size = self nonEmptyMoreThan1Element size .
)

testKeysAndValuesDoEmpty = (
	| result |
	result:= OrderedCollection new.
	self empty  keysAndValuesDo:
		[:i :value|
		result add: (value+i)].
	self assert: result isEmpty .
)

testLast = (
	self assert: self moreThan4Elements last = (self moreThan4Elements at: self moreThan4Elements size)
)

testLastIndexOf = (
	| element collection |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection lastIndexOf: element) = 1.
	self assert: (collection lastIndexOf: self elementNotInForIndexAccessing) = 0
)

testLastIndexOfIfAbsent = (
	| element collection |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection first.
	self assert: (collection
			lastIndexOf: element
			ifAbsent: [ 99 ]) = 1.
	self assert: (collection
			lastIndexOf: self elementNotInForIndexAccessing
			ifAbsent: [ 99 ]) = 99
)

testLastIndexOfStartingAt = (
	| element collection |
	collection := self collectionMoreThan1NoDuplicates.
	element := collection last.
	self assert: (collection
			lastIndexOf: element
			startingAt: collection size
			ifAbsent: [ 99 ]) = collection size.
	self assert: (collection
			lastIndexOf: element
			startingAt: collection size - 1
			ifAbsent: [ 99 ]) = 99.
	self assert: (collection
			lastIndexOf: self elementNotInForIndexAccessing
			startingAt: collection size
			ifAbsent: [ 99 ]) = 99
)

testLastNElements = (
	| result |
	result := self moreThan3Elements last: self moreThan3Elements size - 1.
	1
		to: result size
		do: [ :i | self assert: (result at: i) = (self moreThan3Elements at: i + 1) ].
	self assert: result size = (self moreThan3Elements size - 1).
	self
		should: [ self moreThan3Elements last: self moreThan3Elements size + 1 ]
		raise: Error
)

testMiddle = (
	self assert: self moreThan4Elements middle = (self moreThan4Elements at: self moreThan4Elements size // 2 + 1)
)

testNoneSatisfy = (
	| element |
	self assert: ( self collectionWithoutNilElements  noneSatisfy: [:each | each notNil not ] ).
	element := self collectionWithoutNilElements anyOne.
	self deny: ( self collectionWithoutNilElements  noneSatisfy: [:each | (each = element)not ] ).
)

testNoneSatisfyEmpty = (
	self assert: ( self empty noneSatisfy: [:each | false]).
)

testNotEmpty = (
	self assert: (self nonEmpty  notEmpty).
	self deny: (self empty notEmpty).
)

testOccurrencesOf = (
	| collection |
	collection := self collectionWithoutEqualElements .
	collection do: [ :each | self assert: (collection occurrencesOf: each) = 1 ].
)

testOccurrencesOfEmpty = (
	| result |
	result := self empty occurrencesOf: (self collectionWithoutEqualElements anyOne).
	self assert: result = 0
)

testOccurrencesOfNotIn = (
	| result |
	result := self collectionWithoutEqualElements occurrencesOf: self elementNotInForOccurrences.
	self assert: result = 0
)

testPairsCollect = (
	| index result |
	index:=0.
	result:=self nonEmptyMoreThan1Element  pairsCollect:
		[:each1 :each2 |
		self assert: ( self nonEmptyMoreThan1Element indexOf: each2 ) = (index := index + 2).
		(self nonEmptyMoreThan1Element indexOf: each2) = ((self nonEmptyMoreThan1Element indexOf: each1) + 1).
		].
	result do:
		[:each | self assert: each = true].
)

testPairsDo = (
	| index |
	index:=1.
	self nonEmptyMoreThan1Element  pairsDo:
		[:each1 :each2 |
		self assert:(self nonEmptyMoreThan1Element at:index)=each1.
		self assert:(self nonEmptyMoreThan1Element at:(index+1))=each2.
		index:=index+2].
	self nonEmptyMoreThan1Element size odd
		ifTrue:[self assert: index=self nonEmptyMoreThan1Element size]
		ifFalse:[self assert: index=(self nonEmptyMoreThan1Element size+1)].
)

testPrintElementsOn = (
	| aStream result allElementsAsString tmp |
	result:=''.
	aStream:= ReadWriteStream on: result.
	tmp:= OrderedCollection new.
	self nonEmpty do: [:each | tmp add: each asString].
	self nonEmpty printElementsOn: aStream .
	allElementsAsString:=(result findBetweenSubStrs: ' ' ).
	1 to: allElementsAsString size do:
		[:i |
		self assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i)).
			].
)

testPrintNameOn = (
	| aStream result |
	result:=''.
	aStream:= ReadWriteStream on: result.
	self nonEmpty printNameOn: aStream.
	self nonEmpty class name first isVowel
		ifTrue:[ self assert: aStream contents =('an ',self nonEmpty class name ) ]
		ifFalse:[self assert: aStream contents =('a ',self nonEmpty class name)].
)

testPrintOn = (
	| aStream result allElementsAsString tmp |
	result:=''.
	aStream:= ReadWriteStream on: result.
	tmp:= OrderedCollection new.
	self nonEmpty do: [:each | tmp add: each asString].
	self nonEmpty printOn: aStream .
	allElementsAsString:=(result findBetweenSubStrs: ' ' ).
	1 to: allElementsAsString size do:
		[:i |
		i=1
			ifTrue:[
			self accessCollection class name first isVowel
				ifTrue:[self assert: (allElementsAsString at:i)='an' ]
				ifFalse:[self assert: (allElementsAsString at:i)='a'].].
		i=2
			ifTrue:[self assert: (allElementsAsString at:i)=self accessCollection class name].
		i>2
			ifTrue:[self assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i)).].
			].
)

testPrintOnDelimiter = (
	| aStream result allElementsAsString tmp |
	result:=''.
	aStream:= ReadWriteStream on: result.
	tmp:= OrderedCollection new.
	self nonEmpty do: [:each | tmp add: each asString].
	self nonEmpty printElementsOn: aStream separatedBy: ', ' .
	allElementsAsString:=(result findBetweenSubStrs: ', ' ).
	1 to: allElementsAsString size do:
		[:i |
		self assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i))
			].
)

testReject = (
	| res element |
	res := self collectionWithoutNilElements reject: [:each | each notNil not].
	self assert: res size = self collectionWithoutNilElements size.
	element := self collectionWithoutNilElements anyOne.
	res := self collectionWithoutNilElements  reject: [:each | each = element].
	self assert: res size = (self collectionWithoutNilElements size - 1).
)

testRejectAllThenCollect = (
	| result |
	result := (self collectionWithoutNilElements
		reject: [ :each | each notNil ] )
		collect: [ :each| self fail ].
	self assert: result isEmpty
)

testRejectEmpty = (
	| res |
	res := self empty reject: [:each | each odd].
	self assert: res size = self empty size
)

testRejectNoReject = (
	| res |
	res := self collectionWithoutNilElements  reject: [:each | each notNil not].
	self assert: res size = self collectionWithoutNilElements size.
)

testRejectThenCollect = (
	| result index selectIndex pivot |
	index := 0.
	selectIndex := 0.
	pivot := self collectionWithoutNilElements anyOne.
	result := (self collectionWithoutNilElements
		reject: [ :each |
			selectIndex := selectIndex + 1.
			selectIndex = 1 ])
		collect: [ :each |
			self assert: each notNil.
			index := index + 1.
			pivot ].
	self assert: result ~= self collectionWithoutNilElements.
	self assert: selectIndex equals: self collectionWithoutNilElements size.
	self assert: index equals: self collectionWithoutNilElements size - 1.
	self assert: (self collectionWithoutNilElements occurrencesOf: pivot) equals: 1.
	self assert: (result occurrencesOf: pivot) >= 1.
)

testRejectThenCollectEmpty = (
	self assert: ((self empty reject: [:e | self fail ]) collect: [ :each| self fail ]) isEmpty
)

testRejectThenDoOnEmpty = (
	self assert: (self empty reject: [:e | self fail ] thenDo: [ self fail ]) isEmpty
)

testRemoveAll = (
	| list2 |
	list add: link1.
	list add: link2.
	list add: link3.
	list add: link4.
	list2 := list copy.
	list removeAll.
	self assert: list size = 0.
	self assert: list2 size = 4 description: 'the copy has not been modified'
)

testRemoveAllError = (
	| el aSubCollection |
	el := self elementNotIn.
	aSubCollection := self nonEmptyWithoutEqualElements copyWith: el.
	self
		should: [ | res | res := self nonEmptyWithoutEqualElements removeAll: aSubCollection ]
		raise: Error
)

testRemoveAllFoundIn = (
	| el aSubCollection res |
	el := self nonEmptyWithoutEqualElements anyOne.
	aSubCollection := (self nonEmptyWithoutEqualElements copyWithout: el) copyWith: self elementNotIn.
	res := self nonEmptyWithoutEqualElements removeAllFoundIn: aSubCollection.
	self assert: self nonEmptyWithoutEqualElements size = 1.
	self nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]
)

testRemoveAllSuchThat = (
	| el aSubCollection |
	el := self nonEmptyWithoutEqualElements anyOne.
	aSubCollection := self nonEmptyWithoutEqualElements copyWithout: el.
	self nonEmptyWithoutEqualElements removeAllSuchThat: [ :each | aSubCollection includes: each ].
	self assert: self nonEmptyWithoutEqualElements size = 1.
	self nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]
)

testRemoveElementFromEmpty = (
	self
		should: [ self empty remove: self nonEmptyWithoutEqualElements anyOne ]
		raise: Error
)

testRemoveElementReallyRemovesElement = (
	| size |
	size := self nonEmptyWithoutEqualElements size.
	self nonEmptyWithoutEqualElements remove: self nonEmptyWithoutEqualElements anyOne.
	self assert: size - 1 = self nonEmptyWithoutEqualElements size
)

testRemoveElementThatExists = (
	| el res |
	el := self nonEmptyWithoutEqualElements anyOne.
	res := self nonEmptyWithoutEqualElements remove: el.
	self assert: res == el
)

testRemoveIfAbsent = (
	| el res |
	el := self elementNotIn.
	res := self nonEmptyWithoutEqualElements remove: el ifAbsent: [ 33 ].
	self assert: res = 33
)

testReverse = (
	| result |
	result := self nonEmpty reversed.
	1 to: result size do:
		[:i | self assert: ((result at: i)
			= (self nonEmpty at: (self nonEmpty size - i + 1)))].
	self assert: result size=self nonEmpty size.
)

testReverseDo = (
	| result |
	result:= OrderedCollection new.
	self nonEmpty reverseDo: [: each | result add: each].
	1 to: result size do:
		[:i|
		self assert: (result at: i)=(self nonEmpty at:(self nonEmpty size-i+1))].
)

testReverseDoEmpty = (
	| result |
	result:= OrderedCollection new.
	self empty reverseDo: [: each | result add: each].
	self assert: result isEmpty .
)

testReverseWithDo = (
	| firstCollection secondCollection index |
	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := firstCollection size.
	firstCollection  reverseWith: secondCollection do:
		[:a :b |
		self assert: (firstCollection at: index) equals:  a.
		self assert: (secondCollection at: index) equals:  b.
			( index := index - 1).]
)

testReversed = (
	| result |
	result := self nonEmpty reversed .
	1 to:  result size do:
		[:i | self assert: ((result at:i)=(self nonEmpty at:(self nonEmpty size-i+1)))].
	self assert: result size=self nonEmpty size.
)

testSelect = (
	| result element |
	result := self collectionWithoutNilElements select: [ :each | each notNil].
	self assert: result size equals: self collectionWithoutNilElements size.
	element := self collectionWithoutNilElements anyOne.
	result := self collectionWithoutNilElements select: [ :each | (each = element) not].
	self assert: result size equals: (self collectionWithoutNilElements size - 1).
)

testSelectNoneThenCollect = (
	| result |
	result := self collectionWithoutNilElements
		select: [ :each | each isNil ]
		thenCollect: [ :each| self fail ].
	self assert: result isEmpty
)

testSelectOnEmpty = (
	self assert: (self empty select: [:e | self fail]) isEmpty
)

testSelectThenCollect = (
	| result index selectIndex pivot |
	index := 0.
	selectIndex := 0.
	pivot := self collectionWithoutNilElements anyOne.
	result := self collectionWithoutNilElements
		select: [ :each |
			selectIndex := selectIndex + 1.
			selectIndex > 1 ]
		thenCollect: [ :each |
			self assert: each notNil.
			index := index + 1.
			pivot ].
	self assert: result ~= self collectionWithoutNilElements.
	self assert: selectIndex equals: self collectionWithoutNilElements size.
	self assert: index equals: self collectionWithoutNilElements size - 1.
	self assert: (self collectionWithoutNilElements occurrencesOf: pivot) equals: 1.
	self assert: (result occurrencesOf: pivot) >= 1.
)

testSelectThenCollectOnEmpty = (
	self assert: (self empty select: [:e | self fail ] thenCollect: [ self fail ]) isEmpty
)

testSelectThenDoOnEmpty = (
	self assert: (self empty select: [:e | self fail ] thenDo: [ self fail ]) isEmpty
)

testShallowCopy = (
	| result |
	result := self nonEmpty shallowCopy .
	1 to: self nonEmpty size do:
		[:i | self assert: ((result at:i)=(self nonEmpty at:i))].
	self assert: result size=self nonEmpty size.
)

testShallowCopyEmpty = (
	| result |
	result := self empty shallowCopy .
	self assert: result isEmpty .
)

testShuffled = (
	| result |
	result := self nonEmpty shuffled .
	result do: [:each | self assert: (self nonEmpty occurrencesOf: each)=(result occurrencesOf: each)].
	self assert: result size=self nonEmpty size.
)

testStoreOn = (
)

testSumNumbers = (
	|result|
	result:= self collectionWithoutNilElements
		detectSum: [ :ele | ele notNil ifTrue: [ 1 ] ifFalse: [ 0 ]].
	self assert: self collectionWithoutNilElements size = result
)

testSwapAdjacent = (
	|aList|
	aList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.
	aList swap: 3 with: 4.
	self assert: (aList at: 3) equals: 2.
	self assert: (aList at: 4) equals: 3.
)

testSwapAdjacentEnd = (
	|aList|
	aList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.
	aList swap: 4 with: 5.
	self assert: (aList at: 4) equals: 1.
	self assert: (aList at: 5) equals: 2.
	self assert: aList last equals: 2.
)

testSwapAdjacentStart = (
	|aList|
	aList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.
	aList swap: 1 with: 2.
	self assert: (aList at: 1) equals: 4.
	self assert: (aList at: 2) equals: 5.
	self assert: aList first equals: 4.
)

testSwapBasic = (
	|aList|
	aList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.
	aList swap: 2 with: 4.
	self assert: (aList at: 2) equals: 2.
	self assert: (aList at: 4) equals: 4.
)

testSwapStartAndEnd = (
	|aList|
	aList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.
	aList swap: 1 with: 5.
	self assert: (aList at: 1) equals: 1.
	self assert: (aList at: 5) equals: 5.
	self assert: aList first equals: 1.
	self assert: aList last equals: 5.
)

testTAdd = (
	| added |
	added := self otherCollection add: self element.
	self assert: added = self element.
	self assert: (self otherCollection includes: self element).
)

testTAddAll = (
	| added collection toBeAdded |
	collection := self collectionWithElement .
	toBeAdded := self otherCollection .
	added := collection addAll: toBeAdded .
	self assert: added == toBeAdded .
	self assert: (collection includesAllOf: toBeAdded )
)

testTAddIfNotPresentWithElementAlreadyIn = (
	| added oldSize collection anElement |
	collection := self collectionWithElement .
	oldSize := collection size.
	anElement := self element .
	self assert: (collection  includes: anElement ).
	added := collection  addIfNotPresent: anElement .
	self assert: added == anElement .
	self assert: collection  size = oldSize
)

testTAddIfNotPresentWithNewElement = (
	| added oldSize collection elem |
	collection := self otherCollection .
	oldSize := collection  size.
	elem := self element .
	self deny: (collection  includes: elem ).
	added := collection  addIfNotPresent: elem .
	self assert: added == elem .
	self assert: (collection  size = (oldSize + 1)).
)

testTWrite = (
	| added collection elem |
	collection := self otherCollection  .
	elem := self element .
	added := collection  write: elem .
	self assert: added == elem .
	self assert: (collection  includes: elem )	.
	self assert: (collection  includes: elem ).
)

testUnion = (
	| union |
	union := self empty union: self nonEmpty.
	self containsAll: union of: self empty andOf: self nonEmpty.
	union := self nonEmpty union: self empty.
	self containsAll: union of: self empty andOf: self nonEmpty.
	union := self collection union: self nonEmpty.
	self containsAll: union of: self collection andOf: self nonEmpty.
)

testUnionOfEmpties = (
	self assert:  (self empty union: self empty) isEmpty.
)

testWithCollect = (
	| result firstCollection secondCollection index  |
	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := 0.
	result := firstCollection  with: secondCollection collect:
		[:a :b |
		( index := index + 1).
		self assert: (firstCollection at: index) equals:  a.
		self assert: (secondCollection at: index) equals:  b.
		b].
	1 to: result size do:[: i | self assert: (result at:i)= (secondCollection  at: i)].
	self assert: result size = secondCollection  size.
)

testWithCollectError = (
	self should: [self nonEmptyMoreThan1Element with: self empty collect:[:a :b | ]] raise: Error.
)

testWithDo = (
	| firstCollection secondCollection index |
	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := 0.
	firstCollection  with: secondCollection do:
		[:a :b |
		( index := index + 1).
		self assert: (firstCollection at: index) equals:  a.
		self assert: (secondCollection at: index) equals:  b.]
)

testWithDoError = (
	self should: [self nonEmptyMoreThan1Element with: self empty do:[:a :b | ]] raise: Error.
)

testWithIndexCollect = (
	| result index collection |
	index := 0.
	collection := self nonEmptyMoreThan1Element .
	result := collection  withIndexCollect: [:each :i |
		self assert: i = (index := index + 1).
		self assert: i = (collection  indexOf: each) .
		each] .
	1 to: result size do:[: i | self assert: (result at:i)= (collection at: i)].
	self assert: result size = collection size.
)

testWithIndexDo = (
	|  indexes elements |
	indexes:= OrderedCollection new.
	elements := OrderedCollection new.
	self nonEmptyMoreThan1Element  withIndexDo:
		[:value :i  |
		indexes  add: (i).
		elements add: value].
	(1 to: self nonEmptyMoreThan1Element size )do:
		[ :i |
		self assert: (indexes at: i) = i.
		self assert: (elements at: i) = (self nonEmptyMoreThan1Element at: i).
		].
	self assert: indexes size = elements size.
	self assert: indexes size = self nonEmptyMoreThan1Element size .
)

testsBeginsWith = (
	self assert: (self nonEmpty beginsWith:(self nonEmpty copyUpTo: self nonEmpty last)).
	self assert: (self nonEmpty beginsWith:(self nonEmpty )).
	self deny: (self nonEmpty beginsWith:(self nonEmpty copyWith:self nonEmpty first)).
)

testsBeginsWithEmpty = (
	self deny: (self nonEmpty beginsWith:(self empty)).
	self deny: (self empty beginsWith:(self nonEmpty )).
)

testsEndsWith = (
	self assert: (self nonEmpty endsWith: self nonEmpty allButFirst).
	self assert: (self nonEmpty endsWith: self nonEmpty).
	self deny: (self nonEmpty endsWith: (self nonEmpty copyWith: self nonEmpty first)).
)

testsEndsWithEmpty = (
	self deny: (self nonEmpty endsWith: self empty).
	self deny: (self empty endsWith: self nonEmpty).
)

)
