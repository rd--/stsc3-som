String = ArrayedCollection (

< aString = (
	"Answer true if and only if the receiver collates before aString.  The collation
	sequence is ascii with case differences."
	^(self compare: aString) = 1
)

<= aString = (
	"Answer true if and only if the receiver collates before aString or is the
	same as aString.  The collation sequence is ascii with case differences."
	^(self compare: aString) <= 2
)

> aString = (
	"Answer true if and only if the receiver collates after aString.  The collation
	sequence is ascii with case differences."
	^(self compare: aString) = 3
)

>= aString = (
	"Answer true if and only if the receiver collates after aString or is the
	same as aString.  The collation sequence is ascii with case differences."
	^(self compare: aString) >= 2
)

, anObject = (
	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: anObject asString
)

asInteger = (
	^ SmallInteger fromString: self
)

asNumber = (
	(self anySatisfy: [ :char | char = $. ])
		ifTrue: [ ^ Float readFrom: self ]
		ifFalse: [ ^ Integer readFrom: self ]
)

asString = (
	^self
)

asSymbol = (
	<primitive: -1>
	self primitiveFailed
)

at: index = (
	"Answer the Character stored in the field of the receiver indexed by the
	argument.  Fail if the index argument is not an Integer or is out of bounds.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 63>
	^Character value: (super at: index)

)

at: index put: aCharacter = (
	"Store the Character in the field of the receiver indicated by the index.  Fail if the
	index is not an Integer or is out of bounds, or if the argument is not a Character.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 64>
	(aCharacter isKindOf: Character)
		ifTrue: [self errorNonIntegerIndex]
		ifFalse: [self error: 'Strings only store Characters']

)

basicAt: index = (
	"Answer the Character stored in the field of the receiver indexed by the
	argument.  Fail if the index argument is not an Integer or is out of bounds.
	Essential.  See Object documentation whatIsAPrimitive."
	<primitive: 63>
	^Character value: (super at: index)
)

basicAt: index put: aCharacter = (
	"Store the Character in the field of the receiver indicated by the index.  Fail if the
	index is not an Integer or is out of bounds, or if the argument is not a Character.
	Essential.  See Object documentation whatIsAPrimitive."
	<primitive: 64>
	(aCharacter isKindOf: Character)
		ifTrue: [self errorNonIntegerIndex]
		ifFalse: [self error: 'Strings only store Characters']
)

compare: s = (
	^ self compare: s withNormalisingBlock: [ :aCharacter | aCharacter ]
)

caseInsensitiveCompare: s = (
	^ self compare: s withNormalisingBlock: [ :aCharacter | aCharacter asUppercase ]
)

compare: s withNormalisingBlock: aBlock = (
	| i len endResult u1 u2 mylen |
	mylen := self size.
	len := s size.
	mylen < len
		ifTrue:
			[len := mylen.
			endResult := 1]
		ifFalse: [endResult := mylen = len
						ifTrue: [2]
						ifFalse: [3]].
	i := 0.
	[(i := i + 1) <= len]
		whileTrue:
			[u1 := self at: i.
			u2 := s at: i.
			u1 = u2
				ifFalse:
					[u1 := aBlock value: u1.
					u2 := aBlock value: u2.
					u1 = u2 ifFalse:
						[^u1 < u2
							ifTrue: [1]
							ifFalse: [3]]]].
	^endResult
)


isLiteral = (
	^true
)

isString = (
	^ true
)

print = (
	Smalltalk printString: self
)

printAsLiteralOn: aStream = (
	self storeOn: aStream
)

printOn: aStream = (
	self storeOn: aStream
)

replaceFrom: start to: stop with: replacement startingAt: repStart = (
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."
	<primitive: 105>
	super replaceFrom: start to: stop with: replacement startingAt: repStart
)

size = (
	"Answer the number of indexable fields in the receiver.  This value is the
	same as the largest legal subscript.  Essential.  See Object documentation
	whatIsAPrimitive."
	<primitive: 62>
	^self basicSize
)

storeOn: aStream = (
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x := self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'
)

withBlanksTrimmed = (
	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."
	| first last |
	first := self indexOfNoneOf: CharacterSet separators startingAt: 1.
	first = 0 ifTrue: [ ^'' ].  "no non-separator character"
	last := self lastIndexOfNoneOf: CharacterSet separators startingAt: self size ifAbsent: [self size].
	(first = 1 and: [ last = self size ]) ifTrue: [ ^self copy ].
	^self
		copyFrom: first
		to: last
)

----

cr = (
	"Answer a string containing a single carriage return character."
	^ self with: Character cr
)

crlf = (
	"Answer a string containing a carriage return and a linefeed."
	^ self with: Character cr with: Character lf
)

empty = (
	"A canonicalized empty String instance."
	^ ''
)

isVariable = (
	^true
)

lf = (
	"Answer a string containing a single carriage return character."
	^ self with: Character lf
)

space = (
	"Answer a string containing a single space character."
	^ self with: Character space
)

tab = (
	"Answer a string containing a single tab character."
	^ self with: Character tab
)

value: anInteger = (
	^ self with: (Character value: anInteger).
)

)
