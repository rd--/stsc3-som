String = ArrayedCollection (

, anObject = (
	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: anObject asString
)

asInteger = (
	^ SmallInteger fromString: self
)

asString = (
	^self
)

asSymbol = (
	<primitive: -1>
	self primitiveFailed
)

at: index = (
	"Answer the Character stored in the field of the receiver indexed by the
	argument.  Fail if the index argument is not an Integer or is out of bounds.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 63>
	^Character value: (super at: index)

)

at: index put: aCharacter = (
	"Store the Character in the field of the receiver indicated by the index.  Fail if the
	index is not an Integer or is out of bounds, or if the argument is not a Character.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 64>
	(aCharacter isKindOf: Character)
		ifTrue: [self errorNonIntegerIndex]
		ifFalse: [self error: 'Strings only store Characters']

)

basicAt: index = (
	"Answer the Character stored in the field of the receiver indexed by the
	argument.  Fail if the index argument is not an Integer or is out of bounds.
	Essential.  See Object documentation whatIsAPrimitive."
	<primitive: 63>
	^Character value: (super at: index)
)

basicAt: index put: aCharacter = (
	"Store the Character in the field of the receiver indicated by the index.  Fail if the
	index is not an Integer or is out of bounds, or if the argument is not a Character.
	Essential.  See Object documentation whatIsAPrimitive."
	<primitive: 64>
	(aCharacter isKindOf: Character)
		ifTrue: [self errorNonIntegerIndex]
		ifFalse: [self error: 'Strings only store Characters']
)

isLiteral = (
	^true
)

primReplaceFrom: start to: stop with: replacement startingAt: repStart = (
	"This destructively replaces elements from start to stop in the receiver
	starting at index, repStart, in the collection, replacement.  Answer the
	receiver.  No range checks are performed - this may be primitively implemented."
	<primitive: 105>
	super replaceFrom: start to: stop with: replacement startingAt: repStart
)

print = (
	Smalltalk printString: self
)

printAsLiteralOn: aStream = (
	self storeOn: aStream
)

printOn: aStream = (
	self storeOn: aStream
)

size = (
	"Answer the number of indexable fields in the receiver.  This value is the
	same as the largest legal subscript.  Essential.  See Object documentation
	whatIsAPrimitive."
	<primitive: 62>
	^self basicSize
)

storeOn: aStream = (
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x := self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'
)

----

isVariable = (
	^true
)

)
