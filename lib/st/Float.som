Float = Number (

abs = (
	^(self < 0.0) ifTrue: [ ^0.0 - self ] ifFalse: [ ^self ]
)

asFloat = (
)

closeTo: num = (
 	"are these two numbers close?"
	num isNumber ifFalse: [^[self = num] ifError: [false]].
	self = 0.0 ifTrue: [^num abs < 0.0001].
	num = 0 ifTrue: [^self abs < 0.0001].
	^self = num asFloat
		or: [(self - num) abs / (self abs max: num abs) < 0.0001]
)

cos = (
	^ (self + Float halfPi) sin
)

degreeCos = (
	"Take care of exceptional values"
	self isFinite ifTrue: [^super degreeCos].
	^self degreesToRadians cos
)

degreeSin = (
	"Take care of exceptional values"
	self isFinite ifTrue: [^super degreeSin].
	^self degreesToRadians sin
)

degreesToRadians = (
	^self * Float radiansPerDegree
)

hash = (
	(self isFinite and: [self fractionPart = 0.0]) ifTrue: [^self truncated hash].
	^self identityHash
)

integerPart = (
	^self - self fractionPart
)

isFinite = (
	^(self - self) = 0.0
)

isFloat = (
	^true
)

isInfinite = (
	"Return true if the receiver is positive or negative infinity."
	^ self = Float infinity or: [self = Float negativeInfinity]
)

isLiteral = (
	^true
)

isNaN = (
	"simple, byte-order independent test for Not-a-Number"
	^ self ~= self
)

isPowerOfTwo = (
	^false
)

isZero = (
	^self = 0.0
)

log = (
	^ self ln / Float ln10
)

log2 = (
	^ self significand ln / Float ln2 + self exponent
)

negated = (
	^-1.0 * self
)

predecessor = (
	^ self - Float epsilon
)

printAsLiteralOn: aStream = (
	^self storeOn: aStream
)

radiansToDegrees = (
	^self / Float radiansPerDegree
)

reciprocal = (
	^1.0 / self
)

rounded = (
	self fractionPart abs < 0.5
		ifTrue: [^self truncated]
		ifFalse: [^self truncated + self sign rounded]
)

significand = (
	^ self timesTwoPower: (self exponent negated)
)

successor = (
	^ self + Float epsilon
)

tan = (
	^ self sin / self cos
)

timesTwoPower: anInteger = (
	"Answer with the receiver multiplied by 2.0 raised to the power of the argument"
	self isFinite ifFalse: [^self].
	self isZero ifTrue: [^self].
	anInteger > -30 ifTrue: [
		anInteger < 0 ifTrue: [^ self / (1 bitShift: 0 - anInteger) asFloat].
		anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat]].
	^ self * (2.0 raisedToInteger: anInteger)
)

----

e = (
	^ 2.718281828459045235360287471353
)

epsilon = (
	^ 0.000000000001
)

halfPi = (
	^  Float pi / 2
)

infinity = (
	^ 1.0 / 0.0
)

ln2 = (
	^ 0.69314718055994530941723212145817657
)

ln10 = (
	^10.0 ln
)

nan = (
	^ 0.0 / 0.0
)

negativeInfinity = (
	^ 0.0 - Float infinity
)

one = (
	^ 1.0
)

pi = (
	^  3.14159265358979323846264338327950288
)

radiansPerDegree = (
	^ Float pi / 180.0
)

readFrom: aStream = (
	^(super readFrom: aStream) asFloat
)

readFrom: aStream ifFail: aBlock = (
	^(super readFrom: aStream ifFail: [^aBlock value]) asFloat
)

sqrt2 = (
	^ 1.41421356237309504880168872420969808
)

threePi = (
	^ Float pi * 3.0
)

twoPi = (
	^ Float pi * 2.0
)

zero = (
	^ 0.0
)

)
