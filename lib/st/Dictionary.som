Dictionary = HashedCollection (

associationAt: key = (
	^self associationAt: key ifAbsent: [self errorKeyNotFound]
)

associationAt: key ifAbsent: aBlock = (
	| index |
	index := self findKey: key ifAbsent: [^aBlock value].
	^self basicAt: index
)

associations = (
	| aCollection key |
	aCollection := OrderedCollection new: self size.
	self associationsDo: [:key | aCollection add: key].
	^aCollection
)

at: key = (
	^self at: key ifAbsent: [self errorKeyNotFound]
)

at: key ifAbsent: aBlock = (
	| index |
	index := self findKey: key ifAbsent: [^aBlock value].
	^(self basicAt: index) value
)

at: key put: anObject = (
	| index element |
	index := self findKeyOrNil: key.
	element := self basicAt: index.
	element == nil
		ifTrue: [self atNewIndex: index put: (Association key: key value: anObject)]
		ifFalse: [element value: anObject].
	^anObject
)

keyAtValue: value = (
	^self keyAtValue: value ifAbsent: [self errorValueNotFound]
)

keyAtValue: value ifAbsent: exceptionBlock = (
	self associationsDo:
		[:association | value == association value ifTrue: [^association key]].
	^exceptionBlock value
)

keys = (
	| aSet key |
	aSet := Set new: self size.
	self keysDo: [:key | aSet add: key].
	^aSet
)

values = (
	| aBag |
	aBag := Bag new.
	self do: [:value | aBag add: value].
	^aBag
)

add: anAssociation = (
	| index element |
	index := self findKeyOrNil: anAssociation key.
	element := self basicAt: index.
	element == nil
		ifTrue: [self atNewIndex: index put: anAssociation]
		ifFalse: [element value: anAssociation value].
	^anAssociation
)

declare: key from: aDictionary = (
	(self includesKey: key) ifTrue: [^self].
	(aDictionary includesKey: key)
		ifTrue:
			[self add: (aDictionary associationAt: key).
			aDictionary removeKey: key]
		ifFalse:
			[self at: key put: nil]
)

grow = (
	| newSelf |
	newSelf := self species new: self basicSize + self growSize.
	self associationsDo: [:each | newSelf noCheckAdd: each].
	self become: newSelf
)

asSortedCollection = (
	| aSortedCollection |
	aSortedCollection := SortedCollection new: self size.
	self associationsDo: [:association | aSortedCollection add: association].
	^aSortedCollection
)

associationsDo: aBlock = (
	super do: aBlock
)

keysDo: aBlock = (
	self associationsDo: [:association | aBlock value: association key]
)

removeAssociation: anAssociation = (
	^self removeAssociation: anAssociation ifAbsent: [self errorNotFound]
)

removeAssociation: anAssociation ifAbsent: anExceptionBlock = (
	^super remove: anAssociation ifAbsent: anExceptionBlock
)

removeKey: key = (
	^self removeKey: key ifAbsent: [self errorKeyNotFound]
)

removeKey: key ifAbsent: aBlock = (
	| index element |
	index := self findKey: key ifAbsent: [^aBlock value].
	element := self basicAt: index.
	self basicAt: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^element
)

includesAssociation: anAssociation = (
	^super includes: anAssociation
)

includesKey: key = (
	| index |
	index := self findKeyOrNil: key.
	^(self basicAt: index) ~~ nil
)

collect: aBlock = (
	| newCollection |
	newCollection := Bag new.
	self do: [:each | newCollection add: (aBlock value: each)].
	^newCollection
)

do: aBlock = (
	super do: [:assoc | aBlock value: assoc value]
)

select: aBlock = (
	| newCollection |
	newCollection := self species new.
	self associationsDo:
		[:each |
		(aBlock value: each value) ifTrue: [newCollection add: each]].
	^newCollection
)

printOn: aStream = (
	| tooMany |
	tooMany := aStream position + self maxPrint.
	aStream nextPutAll: self class name, ' ('.
	self associationsDo:
		[:element |
		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].
		element printOn: aStream.
		aStream space].
	aStream nextPut: $)
)

storeOn: aStream = (
	| noneYet |
	aStream nextPutAll: '(('.
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' new)'.
	noneYet := true.
	self associationsDo:
			[:each |
			noneYet
				ifTrue: [noneYet := false]
				ifFalse: [aStream nextPut: $;].
			aStream nextPutAll: ' add: '.
			aStream store: each].
	noneYet ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)
)

errorKeyNotFound = (
	self error: 'key not found'
)

errorValueNotFound = (
	self error: 'value not found'
)

findKey: key ifAbsent: aBlock = (
	| index |
	index := self findKeyOrNil: key.
	(self basicAt: index) == nil ifTrue: [^aBlock value].
	^index
)

findKeyOrNil: key = (
	| location length probe pass |
	length := self basicSize.
	pass := 1.
	location := key hash \\ length + 1.
	[(probe := self basicAt: location) == nil or: [probe key = key]]
		whileFalse:
			[(location := location + 1) > length
				ifTrue:
					[location := 1.
					pass := pass + 1.
					pass > 2 ifTrue: [^self grow findKeyOrNil: key]]].
	^location
)

rehash = (
	| newSelf |
	newSelf := self species new: self basicSize.
	self associationsDo: [:each | newSelf noCheckAdd: each].
	self become: newSelf
)

remove: anObject = (
	self shouldNotImplement
)

remove: anObject ifAbsent: exceptionBlock = (
	self shouldNotImplement
)

includes: anObject = (
	self do: [:each | anObject = each ifTrue: [^true]].
	^false
)

occurrencesOf: anObject = (
	| count |
	count := 0.
	self do: [:each | anObject = each ifTrue: [count := count + 1]].
	^count
)

----

newFrom: aDict = (
	| newDictionary |
	newDictionary := self new: aDict size.
	aDict associationsDo:
		[:x |
		(newDictionary includesKey: x key)
			ifTrue: [self error: 'Duplicate key: ', x key printString]
			ifFalse: [newDictionary add: x copy]].
	^ newDictionary
)

newFromPairs: anArray = (
	| newDictionary |
	newDictionary := self new: (anArray size/2).
	1 to: (anArray size-1) by: 2 do: [ :i|
		newDictionary at: (anArray at: i) put: (anArray at: i+1).
	].
	^ newDictionary
)

)
