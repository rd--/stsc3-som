Dictionary = HashedCollection (

associationAt: key = (
	^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]
)

associationAt: key ifAbsent: aBlock = (
	^(array at: (self scanFor: key)) ifNil: [ aBlock value ]
)

associationClass = (
	^Association
)

associations = (
	^Array new: self size streamContents: [ :stream |
		self associationsDo: [ :each | stream nextPut: each ] ]
)

associationsDo: aBlock = (
	tally = 0 ifTrue: [ ^self].
	1 to: array size do: [ :index |
		(array at: index) ifNotNil: [ :element |
			aBlock value: element ] ]
)

at: key = (
	^ self at: key ifAbsent: [self errorKeyNotFound: key]
)

at: key ifAbsentPut: aBlock = (
	^ self at: key ifAbsent: [self at: key put: aBlock value]
)

at: key ifAbsent: aBlock = (
	^((array at: (self scanFor: key)) ifNil: [ aBlock ]) value
)

at: key ifPresent: oneArgBlock ifAbsent: absentBlock = (
	^(array at: (self scanFor: key))
		ifNil: [absentBlock value]
		ifNotNil: [:association| oneArgBlock value: association value]
)

at: key ifPresent: oneArgBlock ifAbsentPut: absentBlock = (
	| index value |
	index := self scanFor: key.
	(array at: index) ifNotNil:
		[:element|
		 ^oneArgBlock value: element value].
	value := absentBlock value.
	self atNewIndex: index put: (self associationClass key: key value: value).
	^value
)

at: key ifPresent: aBlock = (
	| v |
	v := self at: key ifAbsent: [^ nil].
	^ aBlock value: v
)

at: key put: anObject = (
	| index |
	index := self scanFor: key.
	(array at: index)
		ifNil: [ self atNewIndex: index put: (self associationClass key: key value: anObject) ]
		ifNotNil: [ :association | association value: anObject ].
	^anObject
)

keyAtIdentityValue: value = (
	^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound]
)

keyAtIdentityValue: value ifAbsent: exceptionBlock = (
	self associationsDo:
		[:association | value == association value ifTrue: [^association key]].
	^exceptionBlock value
)

keyAtValue: value = (
	^self keyAtValue: value ifAbsent: [self errorValueNotFound]
)

keyAtValue: value ifAbsent: exceptionBlock = (
	self associationsDo:
		[:association | value = association value ifTrue: [^association key]].
	^exceptionBlock value
)

keys = (
	^Array new: self size streamContents: [:s| self keysDo: [:key| s nextPut: key]]
)

values = (
	^Array new: self size streamContents: [ :stream |
		self valuesDo: [ :value | stream nextPut: value] ]
)

addAll: aCollection = (
	aCollection == self ifFalse: [
		aCollection associationsDo: [:assoc| self add: assoc].
	].
	^aCollection
)

add: anAssociation = (
	| index |
	index := self scanFor: anAssociation key.
	(array at: index)
		ifNil: [ self atNewIndex: index put: anAssociation ]
		ifNotNil: [ :element |	element value: anAssociation value ].
	^anAssociation
)

= anObject = (
	self == anObject ifTrue: [ ^true ].
	self species == anObject species ifFalse: [ ^false ].
	self size = anObject size ifFalse: [ ^false ].
	self associationsDo: [ :association |
		(anObject at: association key ifAbsent: [ ^false ]) = association value
			ifFalse: [ ^false ] ].
	^true
)

postCopy = (
	super postCopy.
	array := array collect: [ :association |
		association ifNotNil: [ association copy ] ]
)

associationsDo: aBlock = (
	tally = 0 ifTrue: [ ^self].
	1 to: array size do: [ :index |
		(array at: index) ifNotNil: [ :element |
			aBlock value: element ] ]
)

associationsSelect: aBlock = (
	| newCollection |
	newCollection := self copyEmpty.
	self associationsDo: [ :each |
		(aBlock value: each) ifTrue: [ newCollection add: each ] ].
	^newCollection
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new: self size.
	self associationsDo: [ :each |
		newCollection at: each key put: (aBlock value: each value) ].
	^newCollection
)

do: aBlock = (
	self valuesDo: aBlock
)

keysAndValuesDo: aBlock = (
	^self associationsDo:[:assoc|
		aBlock value: assoc key value: assoc value].
)

keysDo: aBlock = (
	self associationsDo: [:association | aBlock value: association key]
)

select: aBlock = (
	| newCollection |
	newCollection := self copyEmpty.
	self associationsDo: [ :each |
		(aBlock value: each value) ifTrue: [
			newCollection add: each copy ] ].
	^newCollection
)

valuesDo: aBlock = (
	self associationsDo: [:association | aBlock value: association value]
)

flattenOnStream: aStream = (
	^aStream writeDictionary: self.
)

printElementsOn: aStream = (
	aStream nextPut: $(.
	self size > 100
		ifTrue: [aStream nextPutAll: 'size '.
			self size printOn: aStream]
		ifFalse: [self keysInOrder
				do: [:key | aStream print: key;
						 nextPutAll: '->';
						 print: (self at: key);
						 space]].
	aStream nextPut: $)
)

storeOn: aStream = (
	| noneYet |
	aStream nextPutAll: '(('.
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' new)'.
	noneYet := true.
	self associationsDo:
			[:each |
			noneYet
				ifTrue: [noneYet := false]
				ifFalse: [aStream nextPut: $;].
			aStream nextPutAll: ' add: '.
			aStream store: each].
	noneYet ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)
)

keysAndValuesRemove: keyValueBlock = (
	| removals |
	removals := OrderedCollection new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc value)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]
)

removeKey: key = (
	^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]
)

removeKey: key ifAbsent: aBlock = (
	| index association |
	index := self scanFor: key.
	association := (array at: index) ifNil: [ ^aBlock value ].
	array at: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^association value
)

remove: anObject ifAbsent: exceptionBlock = (
	self shouldNotImplement
)

includesAssociation: anAssociation = (
  ^ (self
      associationAt: anAssociation key
      ifAbsent: [ ^ false ]) value = anAssociation value
)

includesIdentity: anObject = (
	self do: [:each | anObject == each ifTrue: [^ true]].
	^ false
)

includesKey: key = (
	(array at: (self scanFor: key)) ifNil: [ ^false ] ifNotNil: [ ^true ]
)

isDictionary = (
	^true
)

errorValueNotFound = (
	self error: 'value not found'
)

fillFrom: aCollection with: aBlock = (
	aCollection isDictionary
		ifFalse: [
			aCollection do: [ :element |
				self add: (aBlock value: element) ] ]
		ifTrue: [
			aCollection associationsDo: [ :association |
				self at: association key put: (aBlock value: association value) ] ]
)

fixCollisionsFrom: start = (
	| element index |
	index := start.
	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [
		| newIndex |
		(newIndex := self scanFor: element key) = index ifFalse: [
			array at: newIndex put: element.
			array at: index put: nil ] ]
)

noCheckNoGrowFillFrom: anArray = (
	1 to: anArray size do: [ :index |
		(anArray at: index) ifNotNil: [ :association |
			array
				at: (self scanForEmptySlotFor: association key)
				put: association ] ]
)

scanFor: anObject = (
	| index start size |
	index := start := anObject hash \\ (size := array size) + 1.
	[
		| element |
		((element := array at: index) == nil or: [ anObject = element key ])
			ifTrue: [ ^index ].
		(index := index \\ size + 1) = start ] whileFalse.
	self errorNoFreeSpace
)

----------------------------

newFrom: aDict = (
	| newDictionary |
	newDictionary := self new: aDict size.
	aDict associationsDo:
		[:x |
		(newDictionary includesKey: x key)
			ifTrue: [self error: 'Duplicate key: ', x key printString]
			ifFalse: [newDictionary add: x copy]].
	^ newDictionary
)

newFromPairs: anArray = (
	| newDictionary |
	newDictionary := self new: (anArray size/2).
	1 to: (anArray size-1) by: 2 do: [ :i|
		newDictionary at: (anArray at: i) put: (anArray at: i+1).
	].
	^ newDictionary
)

)
