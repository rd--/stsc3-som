Number = Magnitude (

+ aNumber = (
	self subclassResponsibility
)

* aNumber = (
	self subclassResponsibility
)

- aNumber = (
	self subclassResponsibility
)

/ aNumber = (
	self subclassResponsibility
)

// aNumber = (
	^(self / aNumber) floor
)

\\ aNumber = (
	^self - (self // aNumber * aNumber)
)

** aNumber = (
	^ self raisedTo: aNumber
)

abs = (
	^(self < 0) ifTrue: [ self negated ] ifFalse: [ self ]
)

asInteger = (
	^self truncated
)

cos = (
	^self asFloat cos
)

downTo: stop = (
	| answer index |
	answer := Array new: self - stop + 1.
	index := 1.
	self downTo: stop do: [ :item |
		answer at: index put: item.
		index := index + 1
	].
	^answer
)

downTo: stop do: aBlock = (
	self to: stop by: -1 do: aBlock
)

downTo: stop by: step do: aBlock = (
	self to: stop by: step negated do: aBlock
)

floor = (
	| truncation |
	truncation := self truncated.
	self >= 0 ifTrue: [^truncation].
	self = truncation
		ifTrue: [^truncation]
		ifFalse: [^truncation - 1]
)

isNumber = (
	^true
)

ln = (
	^self asFloat ln
)

negated = (
	^0 - self
)

negative = (
	^self < 0
)

quo: aNumber = (
	^(self / aNumber) truncated
)

raisedTo: aNumber = (
	aNumber isInteger	ifTrue: [^self raisedToInteger: aNumber].
	aNumber = 0 ifTrue: [^1].
	aNumber = 1 ifTrue: [^self].
	^(aNumber * self ln) exp
)

raisedToInteger: anInteger = (
	anInteger isInteger ifFalse: [^self error: 'raisedToInteger: only works for integral arguments'].
	anInteger = 0 ifTrue: [^1].
	anInteger = 1 ifTrue: [^self].
	anInteger > 1
		ifTrue: [^(self * self raisedToInteger: anInteger // 2)
					* (self raisedToInteger: anInteger \\ 2)].
	^(self raisedToInteger: anInteger negated) reciprocal
)

reciprocal = (
	^1 / self
)

rem: aNumber = (
	^self - ((self quo: aNumber) * aNumber)
)

rounded = (
	^(self + (self sign / 2)) truncated
)

roundTo: quantum = (
	^(self / quantum) rounded * quantum
)

sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)

sin = (
	^self asFloat sin
)

squared = (
	^self * self
)

sqrt = (
	self subclassResponsibility
)

to: stop = (
	| answer |
	answer := Array new: stop - self + 1.
	self to: stop do: [ :item |
		answer at: item put: item.
	].
	^answer
)

to: stop do: aBlock = (
	| nextValue |
	nextValue := self.
	[nextValue <= stop]
		whileTrue:
			[aBlock value: nextValue.
			nextValue := nextValue + 1]
)

to: stop by: step do: aBlock = (
	| nextValue |
	nextValue := self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue:
					[aBlock value: nextValue.
					nextValue := nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue:
					[aBlock value: nextValue.
					nextValue := nextValue + step]]
)

----

one = (
	^1
)

zero = (
	^0
)

)
