Number = Magnitude (

+ aNumber = (
	self subclassResponsibility
)

* aNumber = (
	self subclassResponsibility
)

- aNumber = (
	self subclassResponsibility
)

/ aNumber = (
	self subclassResponsibility
)

// aNumber = (
	^(self / aNumber) floor
)

\\ aNumber = (
	^self - (self // aNumber * aNumber)
)

** aNumber = (
	^ self raisedTo: aNumber
)

@ y = (
	"Primitive. Answer a Point whose x value is the receiver and whose y
	value is the argument. Optional. No Lookup. See Object documentation
	whatIsAPrimitive."
	<primitive: 18>
	^Point x: self y: y
)

abs = (
	^(self < 0) ifTrue: [ self negated ] ifFalse: [ self ]
)

adaptToCollection: rcvr andSend: selector = (
	"If I am involved in arithmetic with a Collection, return a Collection of
	the results of each element combined with me in that expression."
	^ rcvr collect: [:element | element perform: selector with: self]
)

arCosh = (
	^self asFloat arCosh
)

arSinh = (
	^self asFloat arSinh
)

arTanh = (
	^self asFloat arTanh
)

arcCos = (
	^self asFloat arcCos
)

arcSin = (
	^self asFloat arcSin
)

arcTan = (
	^self asFloat arcTan
)

arcTan: denominator = (
	^(self asFloat) arcTan: denominator.
)

asInteger = (
	^self truncated
)

asNumber = (
	^ self
)

ceiling = (
	"Answer the integer nearest the receiver toward  infinity."
	| truncation |
	truncation := self truncated.
	self <= 0 ifTrue: [^truncation].
	self = truncation
		ifTrue: [^truncation]
		ifFalse: [^truncation + 1]
)

closeTo: num = (
	"are these two numbers close?"
	num isFloat ifTrue: [^ num closeTo: self asFloat].
	^self = num
)

copySignTo: aNumber = (
	"Return a number with same magnitude as aNumber and same sign as self."
	^ self signBit = 0
		ifTrue: [aNumber abs]
		ifFalse: [aNumber abs negated].
)

cos = (
	^self asFloat cos
)

degreeCos = (
	"Answer the cosine of the receiver taken as an angle in degrees."
	^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin
)

degreeSin = (
	"Answer the sine of the receiver taken as an angle in degrees."
	^(90 - self) degreeCos
)

degreesToRadians = (
	^self asFloat degreesToRadians
)

downTo: stop = (
	| answer index |
	answer := Array new: self - stop + 1.
	index := 1.
	self downTo: stop do: [ :item |
		answer at: index put: item.
		index := index + 1
	].
	^answer
)

downTo: stop do: aBlock = (
	self to: stop by: -1 do: aBlock
)

downTo: stop by: step do: aBlock = (
	self to: stop by: step negated do: aBlock
)

even = (
	^self \\ 2 = 0
)

exp = (
	^self asFloat exp
)

factorial = (
	^ self truncated factorial
)

floor = (
	| truncation |
	truncation := self truncated.
	self >= 0 ifTrue: [^truncation].
	self = truncation
		ifTrue: [^truncation]
		ifFalse: [^truncation - 1]
)

floorLog: radix = (
	"Answer the floor of the log base radix of the receiver."
	^(self log: radix) floor
)

fractionPart = (
	^self - self integerPart
)

integerPart = (
	^self truncated
)

isInfinite = (
	^ false
)

isNaN = (
	^ false
)

isNumber = (
	^true
)

isZero = (
	^self = 0
)

log = (
	^self asFloat log
)

log: aNumber = (
	aNumber = 2 ifTrue: [^self log2].
	aNumber isPowerOfTwo ifTrue: [^self log2 / aNumber log2].
	^self ln / aNumber ln
)

log2 = (
	^self asFloat log2
)

ln = (
	^self asFloat ln
)

negated = (
	^0 - self
)

negative = (
	^self < 0
)

odd = (
	^self even == false
)

positive = (
	^ self >= 0
)

printOn: aStream = (
	^self subclassResponsibility
)

quo: aNumber = (
	^(self / aNumber) truncated
)

radiansToDegrees = (
	^self asFloat radiansToDegrees
)

raisedTo: aNumber = (
	aNumber isInteger	ifTrue: [^self raisedToInteger: aNumber].
	aNumber = 0 ifTrue: [^1].
	aNumber = 1 ifTrue: [^self].
	^(aNumber * self ln) exp
)

raisedToInteger: anInteger = (
	anInteger isInteger ifFalse: [^self error: 'raisedToInteger: only works for integral arguments'].
	anInteger = 0 ifTrue: [^1].
	anInteger = 1 ifTrue: [^self].
	anInteger > 1
		ifTrue: [^(self * self raisedToInteger: anInteger // 2)
					* (self raisedToInteger: anInteger \\ 2)].
	^(self raisedToInteger: anInteger negated) reciprocal
)

reciprocal = (
	^1 / self
)

rem: aNumber = (
	^self - ((self quo: aNumber) * aNumber)
)

rounded = (
	^(self + (self sign / 2)) truncated
)

roundTo: quantum = (
	^(self / quantum) rounded * quantum
)

sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)

sign: aNumber = (
	"Return a Number with the same sign as aNumber and same magnitude as self."
	^ aNumber copySignTo: self
)

signBit = (
	"Answer 1 if the receiver is negative, zero otherwise."
	self < 0 ifTrue: [^1].
	^0
)

sin = (
	^self asFloat sin
)

sinh = (
	"Answer receivers hyperbolic sine"
	^self asFloat sinh
)

squared = (
	^self * self
)

sqrt = (
	self subclassResponsibility
)

storeOn: aStream = (
	self printOn: aStream
)

strictlyPositive = (
	"Answer whether the receiver is mathematically positive."
	^ self > 0
)

to: stop = (
	^Interval from: self to: stop
)

to: stop by: step = (
	^Interval from: self to: stop by: step
)

to: aNumber collect: aBlock = (
    ^(self to: aNumber) collect: aBlock
)

to: stop do: aBlock = (
	| nextValue |
	nextValue := self.
	[nextValue <= stop]
		whileTrue:
			[aBlock value: nextValue.
			nextValue := nextValue + 1]
)

to: stop by: step do: aBlock = (
	| nextValue |
	nextValue := self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue:
					[aBlock value: nextValue.
					nextValue := nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue:
					[aBlock value: nextValue.
					nextValue := nextValue + step]]
)

truncated = (
	"Answer an integer nearest the receiver toward zero."
	^self quo: 1
)

truncateTo: aNumber = (
	"Answer the next multiple of aNumber toward zero that is nearest the receiver."
	^(self quo: aNumber) * aNumber
)

----

one = (
	^1
)

readFrom: stringOrStream = (
	"Answer a number as described on stringOrStream.
	If stringOrStream does not start with a valid number description, fail."
	^(FortranNumberParser on: stringOrStream) nextNumber
)

readFrom: stringOrStream ifFail: aBlock = (
	^(FortranNumberParser on: stringOrStream) failBlock: aBlock; nextNumber
)

zero = (
	^0
)

)
