WriteStream = PositionableStream (

| writeLimit |

contents = (
	readLimit := readLimit max: position.
	^collection copyFrom: 1 to: position
)

cr = (
	self nextPut: Character cr
)

crtab = (
	self nextPut: Character cr.
	self nextPut: Character tab
)

crtab: anInteger = (
	self nextPut: Character cr.
	anInteger timesRepeat: [self nextPut: Character tab]
)

nextPut: anObject = (
	<primitive: 66>
	position = writeLimit
		ifTrue: [^self pastEndPut: anObject]
		ifFalse:
			[^collection at: (position := position + 1) put: anObject]
)

next = (
	self shouldNotImplement
)

on: aCollection = (
	super on: aCollection.
	readLimit := 0.
	writeLimit := aCollection size
)

on: aCollection from: firstIndex to: lastIndex = (
	| len |
	collection := aCollection.
	readLimit :=
		writeLimit := lastIndex > (len := collection size)
						ifTrue: [len]
						ifFalse: [lastIndex].
	position := firstIndex <= 1
				ifTrue: [0]
				ifFalse: [firstIndex - 1]
)

pastEndPut: anObject = (
	collection grow.
	writeLimit := collection size.
	collection at: (position := position + 1) put: anObject
)

position: anInteger = (
	readLimit := readLimit max: position.
	super position: anInteger
)

print: anObject = (
	anObject printOn: self
)

reset = (
	readLimit := readLimit max: position.
	position := 0
)

size = (
	^readLimit := readLimit max: position
)

space = (
	self nextPut: Character space
)

store: anObject = (
	anObject storeOn: self
)

tab = (
	self nextPut: Character tab
)

with: aCollection = (
	super on: aCollection.
	position := readLimit := writeLimit := aCollection size
)

----

on: aCollection from: firstIndex to: lastIndex = (
	^self basicNew
		on: aCollection
		from: firstIndex
		to: lastIndex
)

with: aCollection = (
	^self basicNew with: aCollection
)

with: aCollection from: firstIndex to: lastIndex = (
	^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)
)

)
