WriteStream = PositionableStream (

| writeLimit initialPositionOrNil |

contents = (
	"Answer with a copy of my collection from the start to the current position."
	readLimit := readLimit max: position.
	^collection copyFrom: (initialPositionOrNil ifNil: [1]) to: position
)

cr = (
	self nextPut: Character cr
)

crlf = (
	"Append a carriage return and a line feed to the receiver."
	self nextPut: Character cr; nextPut: Character lf
)

crtab = (
	self nextPut: Character cr.
	self nextPut: Character tab
)

crtab: anInteger = (
	self nextPut: Character cr.
	anInteger timesRepeat: [self nextPut: Character tab]
)

ensureASpace = (
	"Append a space character to the receiver IFF there is not one on the end."
	self ensureEndsWith: Character space
)

ensureCr = (
	"Append a cr character to the receiver IFF there is not one on the end."
	self ensureEndsWith: Character cr
)

ensureEndsWith: anObject = (
	"Append anObject to the receiver IFF there is not one on the end."
	self peekLast = anObject ifFalse:
		[self nextPut: anObject]
)

ensureNoSpace = (
	"If there is not one on the end, remove it."
	(position > 0 and: [(collection at: position) = Character space])
		ifTrue: [self skip: -1].
)

growTo: anInteger = (
	"anInteger is the required minimal new size of the collection"
	| oldSize grownCollection newSize |
	oldSize := collection size.
	newSize := anInteger + (oldSize // 4 max: 20).
	grownCollection := collection class new: newSize.
	collection := grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit := collection size.
)

lf = (
	self nextPut: Character lf
)

next: anInteger putAll: aCollection startingAt: startIndex = (
	"Store the next anInteger elements from the given collection."
	| newEnd |
	anInteger > 0 ifFalse: [ ^aCollection ].
	(collection class == aCollection class
		or: [ collection isString
			and: [ aCollection isString
			and: [ collection class format = aCollection class format ] ] ]) "Let Strings with the same field size as collection take the quick route too."
		ifFalse: [ ^super next: anInteger putAll: aCollection startingAt: startIndex ].
	newEnd := position + anInteger.
	newEnd > writeLimit ifTrue:
		[self growTo: newEnd + 10].
	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.
	position := newEnd.
	^aCollection
)

nextPut: anObject = (
	<primitive: 66>
	position = writeLimit
		ifTrue: [^self pastEndPut: anObject]
		ifFalse:
			[^collection at: (position := position + 1) put: anObject]
)

nextPutAll: aCollection = (
	| newEnd |
	(collection class == aCollection class)
		ifFalse: [ ^ super nextPutAll: aCollection ].
	newEnd := position + aCollection size.
	newEnd > writeLimit ifTrue:
		[self growTo: newEnd + 10].
	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position := newEnd.
	^aCollection
)

next = (
	self shouldNotImplement
)

on: aCollection = (
	super on: aCollection.
	readLimit := 0.
	writeLimit := aCollection size
)

on: aCollection from: firstIndex to: lastIndex = (
	| len |
	collection := aCollection.
	readLimit :=
		writeLimit := lastIndex > (len := collection size)
						ifTrue: [len]
						ifFalse: [lastIndex].
	position := firstIndex <= 1
				ifTrue: [0]
				ifFalse: [firstIndex - 1].
	initialPositionOrNil := position + 1
)

pastEndPut: anObject = (
	"Grow the collection by doubling the size, but keeping the growth between 20 and 1000000.
	Then put <anObject> at the current write position."
	collection := collection grownBy: ((collection size max: 20) min: 1000000).
	writeLimit := collection size.
	collection at: (position := position + 1) put: anObject.
	^ anObject
)

peekLast = (
	"Return that item just put at the end of the stream"
	^ position > 0
		ifTrue: [collection at: position]
		ifFalse: [nil]
)

position: anInteger = (
	readLimit := readLimit max: position.
	super position: anInteger
)

print: anObject = (
	anObject printOn: self
)

readStream = (
	"Answer a readStream on my contents truncated to current position.
	Beware, the readStream shares the contents, so it will be modified if I'm written backward."
	readLimit := readLimit max: position.
	^ReadStream on: collection from: (initialPositionOrNil ifNil: [1]) to: position
)

reset = (
	readLimit := readLimit max: position.
	position := 0
)

setToEnd = (
	readLimit := readLimit max: position.
	super setToEnd.
)

size = (
	^readLimit := readLimit max: position
)

space = (
	self nextPut: Character space
)

space: anInteger = (
	"Append anInteger space characters to the receiver."
	anInteger timesRepeat: [self space]
)

store: anObject = (
	anObject storeOn: self
)

tab = (
	self nextPut: Character tab
)

tab: anInteger = (
	anInteger timesRepeat: [self tab]
)

with: aCollection = (
	super on: aCollection.
	position := readLimit := writeLimit := aCollection size
)

----

on: aCollection = (
	^self basicNew on: aCollection
)

on: aCollection from: firstIndex to: lastIndex = (
	^self basicNew
		on: aCollection
		from: firstIndex
		to: lastIndex
)

with: aCollection = (
	^self basicNew with: aCollection
)

with: aCollection from: firstIndex to: lastIndex = (
	^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)
)

)
