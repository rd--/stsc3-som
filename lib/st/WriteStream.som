WriteStream = PositionableStream (

| writeLimit |

contents = (
	readLimit := readLimit max: position.
	^collection copyFrom: 1 to: position
)

cr = (
	self nextPut: Character cr
)

crtab = (
	self nextPut: Character cr.
	self nextPut: Character tab
)

crtab: anInteger = (
	self nextPut: Character cr.
	anInteger timesRepeat: [self nextPut: Character tab]
)

growTo: anInteger = (
	"anInteger is the required minimal new size of the collection"
	| oldSize grownCollection newSize |
	oldSize := collection size.
	newSize := anInteger + (oldSize // 4 max: 20).
	grownCollection := collection class new: newSize.
	collection := grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit := collection size.
)

next: anInteger putAll: aCollection startingAt: startIndex = (
	"Store the next anInteger elements from the given collection."
	| newEnd |
	anInteger > 0 ifFalse: [ ^aCollection ].
	(collection class == aCollection class
		or: [ collection isString
			and: [ aCollection isString
			and: [ collection class format = aCollection class format ] ] ]) "Let Strings with the same field size as collection take the quick route too."
		ifFalse: [ ^super next: anInteger putAll: aCollection startingAt: startIndex ].
	newEnd := position + anInteger.
	newEnd > writeLimit ifTrue:
		[self growTo: newEnd + 10].
	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.
	position := newEnd.
	^aCollection
)

nextPut: anObject = (
	<primitive: 66>
	position = writeLimit
		ifTrue: [^self pastEndPut: anObject]
		ifFalse:
			[^collection at: (position := position + 1) put: anObject]
)

next = (
	self shouldNotImplement
)

on: aCollection = (
	super on: aCollection.
	readLimit := 0.
	writeLimit := aCollection size
)

on: aCollection from: firstIndex to: lastIndex = (
	| len |
	collection := aCollection.
	readLimit :=
		writeLimit := lastIndex > (len := collection size)
						ifTrue: [len]
						ifFalse: [lastIndex].
	position := firstIndex <= 1
				ifTrue: [0]
				ifFalse: [firstIndex - 1]
)

pastEndPut: anObject = (
	"Grow the collection by doubling the size, but keeping the growth between 20 and 1000000.
	Then put <anObject> at the current write position."
	collection := collection grownBy: ((collection size max: 20) min: 1000000).
	writeLimit := collection size.
	collection at: (position := position + 1) put: anObject.
	^ anObject
)

position: anInteger = (
	readLimit := readLimit max: position.
	super position: anInteger
)

print: anObject = (
	anObject printOn: self
)

reset = (
	readLimit := readLimit max: position.
	position := 0
)

size = (
	^readLimit := readLimit max: position
)

space = (
	self nextPut: Character space
)

store: anObject = (
	anObject storeOn: self
)

tab = (
	self nextPut: Character tab
)

with: aCollection = (
	super on: aCollection.
	position := readLimit := writeLimit := aCollection size
)

----

on: aCollection from: firstIndex to: lastIndex = (
	^self basicNew
		on: aCollection
		from: firstIndex
		to: lastIndex
)

with: aCollection = (
	^self basicNew with: aCollection
)

with: aCollection from: firstIndex to: lastIndex = (
	^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)
)

)
