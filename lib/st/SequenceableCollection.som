SequenceableCollection = Collection (

= otherCollection = (
	self == otherCollection ifTrue: [^ true].
	self class = otherCollection class ifFalse: [^ false].
	^ self hasEqualElements: otherCollection
)

, otherCollection = (
	"Concatenate two Strings or Collections."
	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: otherCollection asCollection
)

after: target ifAbsent: exceptionBlock = (
	"Answer the element after target.  Answer the result of evaluation
	the exceptionBlock if target is not in the receiver, or if there are
	no elements after it."
	| index |
	index := self indexOf: target.
	^ (index = 0 or: [index = self size])
		ifTrue: [exceptionBlock value]
		ifFalse: [self at: index + 1]
)

any: numberOfElements = (
	^ self first: numberOfElements
)

asArray = (
	^ Array withAll: self
)

atAll: indexArray = (
	| newCollection |
	newCollection := self species ofSize: indexArray size.
	1 to: indexArray size do:
		[:index |
		newCollection at: index put: (self at: (indexArray at: index))].
	^ newCollection
)

atAllPut: anObject = (
	| size |
	(size := self size) > 50
		ifTrue: [self from: 1 to: size put: anObject]
		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]
)

atWrap: index = (
	"Answer the index'th element of the receiver.  If index is out of bounds,
	let it wrap around from the end to the beginning until it is in bounds."
	^ self at: index - 1 \\ self size + 1
)

before: target ifAbsent: exceptionBlock = (
	"Answer the receiver's element immediately before target. Answer
	the result of evaluating the exceptionBlock if target is not an element
	of the receiver, or if there are no elements before it."
	| index |
	index := self indexOf: target.
	^ (index = 0 or: [index = 1])
		ifTrue: [exceptionBlock value]
		ifFalse: [self at: index - 1]
)

beginsWith: sequence = (
	"Answer true if the receiver starts with the argument collection."
	| sequenceSize |
	((sequenceSize := sequence size) = 0 or: [ self size < sequenceSize ]) ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :index |
		(sequence at: index) = (self at: index) ifFalse: [ ^false ] ].
	^true
)

beginsWithAnyOf: aCollection = (
	"Return true if the receiver starts with any of the elements in aCollection."
	^aCollection anySatisfy:[:prefix| self beginsWith: prefix].
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new: self size.
	1 to: self size do:
		[:index |
		newCollection at: index put: (aBlock value: (self at: index))].
	^ newCollection
)

concatenation = (
	"Flattens the collection by one level into an Array. Avoids using #gather: and #streamContents: for performance reasons."
	| result index |
	result := Array new: (self inject: 0 into: [:sum :each | sum + each size]).
	index := 0.
	self do: [:each | each do: [:item | result at: (index := index+1) put: item]].
	^ result
)

copy = (
	^self copyFrom: 1
)

copyFrom: start = (
	^self copyFrom: start to: self size
)

copyFrom: start to: stop = (
	| newSize |
	newSize := stop - start + 1.
	^(self species new: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start
)

copyReplaceFrom: start to: stop with: replacementCollection = (
	| newSequenceableCollection newSize endReplacement |
	endReplacement := start - 1 + replacementCollection size.
	newSize := self size + endReplacement - stop.
	newSequenceableCollection := self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection
)

copyWith: newElement  = (
	"Answer a copy of the receiver that is 1 bigger than the receiver and has
	newElement at the last element."
	| newIC |
	newIC := self species new: self size + 1.
	newIC
		replaceFrom: 1
		to: self size
		with: self
		startingAt: 1.
	newIC at: newIC size put: newElement.
	^newIC
)

do: aBlock = (
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
)

do: elementBlock separatedBy: separatorBlock = (
	1 to: self size do:
		[:index |
		index = 1 ifFalse: [separatorBlock value].
		elementBlock value: (self at: index)]
)

endsWith: sequence = (
	"Answer true if the receiver ends with the argument collection."
	| sequenceSize offset |
	((sequenceSize := sequence size) = 0 or: [ (offset := self size - sequence size) < 0 ]) ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :index |
		(sequence at: index) = (self at: index + offset) ifFalse: [ ^false ] ].
	^true
)

endsWithAnyOf: aCollection = (
	"Return true if the receiver ends with any of the elements in aCollection."
	^aCollection anySatisfy:[:suffix| self endsWith: suffix]
)

fifth = (
	^ self at: 5
)

first = (
	^ self at: 1
)

first: n = (
	"Answer the first n elements of the receiver.
	Raise an error if there are not enough elements."
	^ self copyFrom: 1 to: n
)

flatten = (
	"Similar to #concatenation but removes all nesting except for strings.
Example: {3 .4 .{2 .4 .{'hi'} .'ho'}} flatten = {3 .4 .2 .4 .'hi' .'ho'}"
	^ Array streamContents: [:stream |
		self do: [:each |
			((each isCollection and: [each isString not]) or: [each isStream])
				ifFalse: [stream nextPut: each]
				ifTrue: [stream nextPutAll: each flatten]]]
)

flattened = (
	"An alias for #flatten
	This message's name is in line with messages like #sorted or #reversed
	while #flatten's is in line with #reverse (as per ANSI, see comment there)"
	^ self flatten
)

forceTo: length paddingStartWith: elem = (
	"Force the length of the collection to length, padding
	the beginning of the result if necessary with elem.
	Note that this makes a copy."
	| newCollection padLen |
	newCollection := self species ofSize: length.
	padLen := length - self size max: 0.
	newCollection
		from: 1
		to: padLen
		put: elem.
	newCollection
		replaceFrom: padLen + 1
		to: ((padLen + self size) min: length)
		with: self
		startingAt:  1.
	^ newCollection
)

forceTo: length paddingWith: elem = (
	"Force the length of the collection to length, padding
	if necessary with elem.  Note that this makes a copy."
	| newCollection |
	newCollection := self species new: length withAll: elem.
	newCollection replaceFrom: 1 to: (self size min: length) with: self startingAt: 1.
	^ newCollection
)

fourth = (
	^ self at: 4
)

from: start to: stop do: aBlock = (
	start to: stop do: [:index | aBlock value: (self at: index)]
)

from: startIndex to: endIndex put: anObject = (
	| written toWrite thisWrite |
	startIndex > endIndex ifTrue: [^self].
	self at: startIndex put: anObject.
	written := 1.
	toWrite := endIndex - startIndex + 1.
	[written < toWrite] whileTrue:
		[
			thisWrite := written min: toWrite - written.
			self
				replaceFrom: startIndex + written
				to: startIndex + written + thisWrite - 1
				with: self
				startingAt: startIndex.
			written := written + thisWrite
		].
	^anObject
)

groupsDo: aBlock  = (
	"Evaluate aBlock with my elements taken n at a time, where n is the number of arguments of aBlock. Ignore any leftovers at the end."
	| index argumentArray numArgs endIndex |
	numArgs := aBlock numArgs.
	numArgs
		caseOf: {
			[ 0 ] -> [ ^self error: 'At least one block argument expected.' ].
			[ 1 ] -> [ ^self do: aBlock ].
			[ 2 ] -> [ ^self pairsDo: aBlock ] }
		otherwise: [].
	argumentArray := Array new: numArgs.
	index := 1.
	endIndex := self size - numArgs + 1.
	[ index <= endIndex ] whileTrue: [
		argumentArray
			replaceFrom: 1
			to: numArgs
			with: self
			startingAt: index.
		aBlock valueWithArguments: argumentArray.
		index := index + numArgs ].
)

grownBy: length = (
	"Answer a copy of receiver collection with size grown by length"
	^ (self class ofSize: self size + length)
		replaceFrom: 1 to: self size with: self startingAt: 1 ;
		yourself
)

hasEqualElements: otherCollection = (
	| size |
	otherCollection isSequenceable ifFalse: [^ false].
	(size := self size) = otherCollection size ifFalse: [^ false].
	1 to: size do:
		[:index |
		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].
	^ true
)

includes: anObject = (
	"Answer whether anObject is one of the receiver's elements."
	^ (self indexOf: anObject) ~= 0
)

indexOf: anElement = (
	^self indexOf: anElement startingAt: 1
)

indexOf: anElement startingAt: start = (
	start to: self size do: [ :index |
		(self at: index) = anElement ifTrue: [ ^index ] ].
	^0
)

indexOf: anElement startingAt: start ifAbsent: exceptionBlock = (
	| index |
	(index := self indexOf: anElement startingAt: start) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

indexOf: anElement ifAbsent: exceptionBlock = (
	| index |
	(index := self indexOf: anElement startingAt: 1) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

indexOfAnyOf: aCollection = (
	^self indexOfAnyOf: aCollection startingAt: 1
)

indexOfAnyOf: aCollection startingAt: start = (
	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.
	If the receiver does not contain anElement, answer zero, which is an invalid index."
	start to: self size do: [ :index |
		(aCollection includes: (self at: index)) ifTrue: [ ^index ] ].
	^0
)

indexOfNoneOf: aCollection = (
	^self indexOfNoneOf: aCollection startingAt: 1
)

indexOfNoneOf: aCollection startingAt: start = (
	"Answer the index of the first occurence of any element not included in aCollection after start within the receiver.
	If the receiver does not contain anElement, answer zero, which is an invalid index."
	start to: self size do: [ :index |
		(aCollection includes: (self at: index)) ifFalse: [ ^index ] ].
	^0
)

indexOfSubCollection: aSubCollection = (
	^self
		indexOfSubCollection: aSubCollection
		startingAt: 1
)

indexOfSubCollection: subCollection startingAt: start = (
	| first index subCollectionSize |
	(subCollectionSize := subCollection size) = 0 ifTrue: [ ^0 ].
	first := subCollection at: 1.
	(start max: 1) to: self size - subCollectionSize + 1 do: [ :startIndex |
		(self at: startIndex) = first ifTrue: [
			index := 2.
			[ index <= subCollectionSize
				and: [ (self at: startIndex + index - 1) = (subCollection at: index) ] ]
				whileTrue: [ index := index + 1 ].
			index <= subCollectionSize ifFalse: [ ^startIndex ] ] ].
	^0
)

isSequenceable = (
	^ true
)

join = (
	^ self joinSeparatedBy: ''
)

joinOn: stream = (
	^ self joinOn: stream separatedBy: ''
)

joinOn: stream separatedBy: aSeparator = (
	self
		do: [:ea | stream nextPutAll: ea asString]
		separatedBy: [stream nextPutAll: aSeparator asString].
)

joinSeparatedBy: aSeparator = (
	"Returns a string, which is a concatenation of each element's string representation separated by another string."
	^ String streamContents: [:stream |
		self joinOn: stream separatedBy: aSeparator]
)

last = (
	^ self at: self size
)

last: n = (
	"Answer the last n elements of the receiver.
	Raise an error if there are not enough elements."
	| size |
	size := self size.
	^ self copyFrom: size - n + 1 to: size
)

lastIndexOf: anElement = (
	^self lastIndexOf: anElement startingAt: self size
)

lastIndexOf: anElement startingAt: lastIndex = (
	lastIndex to: 1 by: -1 do: [ :index |
		(self at: index) = anElement ifTrue: [ ^index ] ].
	^0
)

lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock = (
	| index |
	(index := self lastIndexOf: anElement startingAt: lastIndex) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

lastIndexOfAnyOf: aCollection = (
	"Answer the index of the last occurence of any element of aCollection
	within the receiver. If the receiver does not contain any of those
	elements, answer 0"
	^self lastIndexOfAnyOf: aCollection startingAt: self size
)

lastIndexOfAnyOf: aCollection startingAt: lastIndex = (
	"Answer the index of the last occurence of any element of aCollection
	within the receiver. If the receiver does not contain any of those
	elements, answer 0"
	lastIndex to: 1 by: -1 do: [ :index |
		(aCollection includes: (self at: index)) ifTrue: [ ^index ] ].
	^0
)

lastIndexOfAnyOf: aCollection startingAt: lastIndex ifAbsent: exceptionBlock = (
	"Answer the index of the last occurence of any element of aCollection
	within the receiver. If the receiver does not contain any of those
	elements, answer the result of evaluating the argument, exceptionBlock."
	| index |
	(index := self lastIndexOfAnyOf: aCollection startingAt: lastIndex) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

lastIndexOfNoneOf: aCollection startingAt: lastIndex = (
	lastIndex to: 1 by: -1 do: [ :index |
		(aCollection includes: (self at: index)) ifFalse: [ ^index ] ].
	^0
)

lastIndexOfNoneOf: aCollection startingAt: lastIndex ifAbsent: exceptionBlock = (
	| index |
	(index := self lastIndexOfNoneOf: aCollection startingAt: lastIndex) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

overlappingPairsCollect: aBlock = (
	"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements."
	| retval |
	retval := self species ofSize: self size - 1.
	1 to: self size - 1
		do: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].
	^retval
)

overlappingPairsDo: aBlock = (
	"Emit overlapping pairs of my elements into aBlock"
	1 to: self size - 1
		do: [:i | aBlock value: (self at: i) value: (self at: i + 1)]
)

overlappingPairsWithIndexDo: aBlock = (
	"Emit overlapping pairs of my elements into aBlock, along with an index."
	1 to: self size - 1
		do: [:i | aBlock value: (self at: i) value: (self at: i + 1) value: i ]
)

pairsDo: aBlock = (
	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"
	1 to: self size // 2 do:
		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]
)

permutations = (
	| answer |
	answer := OrderedCollection new.
        self permutationsDo: [ :each | answer add: each copy ].
	^answer
)

permutationsDo: aBlock = (
	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy
	so that aBlock is presented all (self size factorial) possible permutations."
	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"
	self shallowCopy permutationsStartingAt: 1 do: aBlock
)

permutationsStartingAt: anInteger do: aBlock = (
	"#(1 2 3 4) permutationsDo: [:each | Transcript cr; show: each printString]"
	anInteger > self size ifTrue: [^self].
	anInteger = self size ifTrue: [^aBlock value: self].
	anInteger to: self size do:
		[:i | self swap: anInteger with: i.
		self permutationsStartingAt: anInteger + 1 do: aBlock.
		self swap: anInteger with: i]
)

putOn: aStream = (
	self do: [ :each | each putOn: aStream ]
)

readStream = (
	^ ReadStream on: self
)

replaceFrom: start to: stop with: replacement = (
	"This destructively replaces elements from start to stop in the receiver.
	Answer the receiver itself. Use copyReplaceFrom:to:with: for
	insertion/deletion which may alter the size of the result."
	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)

replaceFrom: start to: stop with: replacement startingAt: repStart = (
	"This destructively replaces elements from start to stop in the receiver
	starting at index, repStart, in the sequenceable collection,
	replacementCollection. Answer the receiver. No range checks are
	performed."

	| index repOff |
	repOff := repStart - start.
	index := start - 1.
	[(index := index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)

reverse = (
	"The ANSI standard (5.7.8.26) requires this method to return a copy of the receiver. If you want to reverse the collection in place, then use #reverseInPlace."
	^self reversed
)

reverseInPlace = (
	"Reverse this collection in place."
	| start end |
	start := 1.
	end := self size.
	[ start < end ] whileTrue: [
		| temp |
		temp := self at: start.
		self
			at: start put: (self at: end);
			at: end put: temp.
		start := start + 1.
		end := end - 1 ]
)

reversed = (
	"Answer a copy of the receiver with element order reversed."
	"Example: 'frog' reversed"
	| n result src |
	n := self size.
	result := self species ofSize: n.
	src := n + 1.
	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].
	^ result
)

second = (
	^ self at: 2
)

select: aBlock = (
	| aStream |
	aStream := WriteStream on: (self species new: self size).
	1 to: self size do:
		[:index |
		(aBlock value: (self at: index))
			ifTrue: [aStream nextPut: (self at: index)]].
	^ aStream contents
)

shuffle = (
	^self shuffleBy: Random
)

shuffleBy: aRandom = (
	"Durstenfeld's version of the Fisher-Yates shuffle"
	self size to: 2 by: -1 do: [ :i |
		self swap: i with: (aRandom nextInt: i) ]
)

shuffledBy: aRandom = (
	"Durstenfeld's version of the Fisher-Yates shuffle"
	^self copy shuffleBy: aRandom
)

shuffled = (
	^self shuffledBy: Random
)

splitBy: aCollection = (
	^Array streamContents:[:stream|
		self splitBy: aCollection do:[:each| stream nextPut: each].
	].
)

splitBy: aCollection do: aBlock = (
	| lastIndex nextIndex |
	lastIndex := 1.
	[nextIndex := self indexOfSubCollection: aCollection startingAt: lastIndex.
	nextIndex = 0] whileFalse:[
		aBlock value: (self copyFrom: lastIndex to: nextIndex-1).
		lastIndex := nextIndex+ aCollection size.
	].
	aBlock value: (self copyFrom: lastIndex to: self size).
)

swap: oneIndex with: anotherIndex = (
	"Move the element at oneIndex to anotherIndex, and vice-versa."
	| element |
	element := self at: oneIndex.
	self at: oneIndex put: (self at: anotherIndex).
	self at: anotherIndex put: element
)

third = (
	^ self at: 3
)

with: otherCollection collect: twoArgBlock = (
	| result |
	self isOfSameSizeCheck: otherCollection.
	result := self species new: self size.
	1 to: self size do:
		[:index | result at: index put:
		(twoArgBlock
			value: (self at: index)
			value: (otherCollection at: index))].
	^ result
)

with: otherCollection do: twoArgBlock = (
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	self isOfSameSizeCheck: otherCollection.
	1 to: self size do:
		[:index |
		twoArgBlock value: (self at: index)
				value: (otherCollection at: index)]
)

withIndexCollect: elementAndIndexBlock = (
	"Just like with:collect: except that the iteration index supplies the second argument to the block."
	| result |
	result := self species new: self size.
	1 to: self size do:
		[:index | result at: index put:
		(elementAndIndexBlock
			value: (self at: index)
			value: index)].
	^ result
)

withIndexDo: elementAndIndexBlock = (
	"Just like with:do: except that the iteration index supplies the second argument to the block."
	1 to: self size do:
		[:index |
		elementAndIndexBlock
			value: (self at: index)
			value: index]
)

withoutDuplicates = (
	"Answer a copy of the receiver that preserves order but eliminates any duplicates."
	| seen |
	seen := Set new: self size.
	^self select: [:each| seen ifAbsentAdd: each]
)

writeStream = (
	^ WriteStream on: self
)

----

isAbstract = (
	^self = SequenceableCollection
)

new: newSize streamContents: blockWithArg = (
	| stream originalContents |
	stream := WriteStream on: (self new: newSize).
	blockWithArg value: stream.
	originalContents := stream originalContents.
	originalContents size =  stream position
		ifTrue: [ ^originalContents ]
		ifFalse: [ ^stream contents ]
)

streamContents: blockWithArg = (
		^self new: 100 streamContents: blockWithArg
)

streamContents: blockWithArg limitedTo: sizeLimit = (
	| stream |
	stream := LimitedWriteStream on: (self new: (100 min: sizeLimit)).
	stream setLimit: sizeLimit limitBlock: [^ stream contents].
	blockWithArg value: stream.
	^ stream contents
)

)
