SequenceableCollection = Collection (

= otherCollection = (
	self == otherCollection ifTrue: [^ true].
	self class = otherCollection class ifFalse: [^ false].
	^ self hasEqualElements: otherCollection
)

, otherCollection = (
	"Concatenate two Strings or Collections."
	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: otherCollection asCollection
)

asArray = (
	^ Array withAll: self
)

atAll: indexArray = (
	| newCollection |
	newCollection := self species ofSize: indexArray size.
	1 to: indexArray size do:
		[:index |
		newCollection at: index put: (self at: (indexArray at: index))].
	^ newCollection
)

atAllPut: anObject = (
	| size |
	(size := self size) > 50
		ifTrue: [self from: 1 to: size put: anObject]
		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]
)

beginsWith: sequence = (
	"Answer true if the receiver starts with the argument collection."
	| sequenceSize |
	((sequenceSize := sequence size) = 0 or: [ self size < sequenceSize ]) ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :index |
		(sequence at: index) = (self at: index) ifFalse: [ ^false ] ].
	^true
)

beginsWithAnyOf: aCollection = (
	"Return true if the receiver starts with any of the elements in aCollection."
	^aCollection anySatisfy:[:prefix| self beginsWith: prefix].
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new: self size.
	1 to: self size do:
		[:index |
		newCollection at: index put: (aBlock value: (self at: index))].
	^ newCollection
)

copy = (
	^self copyFrom: 1
)

copyFrom: start = (
	^self copyFrom: start to: self size
)

copyFrom: start to: stop = (
	| newSize |
	newSize := stop - start + 1.
	^(self species new: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start
)

copyReplaceFrom: start to: stop with: replacementCollection = (
	| newSequenceableCollection newSize endReplacement |
	endReplacement := start - 1 + replacementCollection size.
	newSize := self size + endReplacement - stop.
	newSequenceableCollection := self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection
)

do: aBlock = (
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
)

do: elementBlock separatedBy: separatorBlock = (
	1 to: self size do:
		[:index |
		index = 1 ifFalse: [separatorBlock value].
		elementBlock value: (self at: index)]
)

endsWith: sequence = (
	"Answer true if the receiver ends with the argument collection."
	| sequenceSize offset |
	((sequenceSize := sequence size) = 0 or: [ (offset := self size - sequence size) < 0 ]) ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :index |
		(sequence at: index) = (self at: index + offset) ifFalse: [ ^false ] ].
	^true
)

endsWithAnyOf: aCollection = (
	"Return true if the receiver ends with any of the elements in aCollection."
	^aCollection anySatisfy:[:suffix| self endsWith: suffix]
)

first = (
	^ self at: 1
)

from: start to: stop do: aBlock = (
	start to: stop do: [:index | aBlock value: (self at: index)]
)

from: startIndex to: endIndex put: anObject = (
	| written toWrite thisWrite |
	startIndex > endIndex ifTrue: [^self].
	self at: startIndex put: anObject.
	written := 1.
	toWrite := endIndex - startIndex + 1.
	[written < toWrite] whileTrue:
		[
			thisWrite := written min: toWrite - written.
			self
				replaceFrom: startIndex + written
				to: startIndex + written + thisWrite - 1
				with: self
				startingAt: startIndex.
			written := written + thisWrite
		].
	^anObject
)

grownBy: length = (
	"Answer a copy of receiver collection with size grown by length"
	^ (self class ofSize: self size + length)
		replaceFrom: 1 to: self size with: self startingAt: 1 ;
		yourself
)

hasEqualElements: otherCollection = (
	| size |
	otherCollection isSequenceable ifFalse: [^ false].
	(size := self size) = otherCollection size ifFalse: [^ false].
	1 to: size do:
		[:index |
		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].
	^ true
)

includes: anObject = (
	"Answer whether anObject is one of the receiver's elements."
	^ (self indexOf: anObject) ~= 0
)

indexOf: anElement = (
	^self indexOf: anElement startingAt: 1
)

indexOf: anElement startingAt: start = (
	start to: self size do: [ :index |
		(self at: index) = anElement ifTrue: [ ^index ] ].
	^0
)

indexOf: anElement startingAt: start ifAbsent: exceptionBlock = (
	| index |
	(index := self indexOf: anElement startingAt: start) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

indexOf: anElement ifAbsent: exceptionBlock = (
	| index |
	(index := self indexOf: anElement startingAt: 1) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

indexOfAnyOf: aCollection = (
	^self indexOfAnyOf: aCollection startingAt: 1
)

indexOfAnyOf: aCollection startingAt: start = (
	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.
	If the receiver does not contain anElement, answer zero, which is an invalid index."
	start to: self size do: [ :index |
		(aCollection includes: (self at: index)) ifTrue: [ ^index ] ].
	^0
)

indexOfSubCollection: aSubCollection = (
	^self
		indexOfSubCollection: aSubCollection
		startingAt: 1
)

indexOfSubCollection: subCollection startingAt: start = (
	| first index subCollectionSize |
	(subCollectionSize := subCollection size) = 0 ifTrue: [ ^0 ].
	first := subCollection at: 1.
	(start max: 1) to: self size - subCollectionSize + 1 do: [ :startIndex |
		(self at: startIndex) = first ifTrue: [
			index := 2.
			[ index <= subCollectionSize
				and: [ (self at: startIndex + index - 1) = (subCollection at: index) ] ]
				whileTrue: [ index := index + 1 ].
			index <= subCollectionSize ifFalse: [ ^startIndex ] ] ].
	^0
)

isSequenceable = (
	^ true
)

last = (
	^ self at: self size
)

lastIndexOf: anElement = (
	^self lastIndexOf: anElement startingAt: self size
)

lastIndexOf: anElement startingAt: lastIndex = (
	lastIndex to: 1 by: -1 do: [ :index |
		(self at: index) = anElement ifTrue: [ ^index ] ].
	^0
)

lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock = (
	| index |
	(index := self lastIndexOf: anElement startingAt: lastIndex) = 0 ifFalse: [ ^index ].
	^exceptionBlock value
)

putOn: aStream = (
	self do: [ :each | each putOn: aStream ]
)

replaceFrom: start to: stop with: replacement = (
	replacement size = (stop - start + 1) ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)

replaceFrom: start to: stop with: replacement startingAt: repStart = (
	| index repOff |
	repOff := repStart - start.
	index := start - 1.
	[(index := index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)

second = (
	^ self at: 2
)

select: aBlock = (
	| aStream |
	aStream := WriteStream on: (self species new: self size).
	1 to: self size do:
		[:index |
		(aBlock value: (self at: index))
			ifTrue: [aStream nextPut: (self at: index)]].
	^ aStream contents
)

splitBy: aCollection = (
	^Array streamContents:[:stream|
		self splitBy: aCollection do:[:each| stream nextPut: each].
	].
)

splitBy: aCollection do: aBlock = (
	| lastIndex nextIndex |
	lastIndex := 1.
	[nextIndex := self indexOfSubCollection: aCollection startingAt: lastIndex.
	nextIndex = 0] whileFalse:[
		aBlock value: (self copyFrom: lastIndex to: nextIndex-1).
		lastIndex := nextIndex+ aCollection size.
	].
	aBlock value: (self copyFrom: lastIndex to: self size).
)

third = (
	^ self at: 3
)

with: otherCollection collect: twoArgBlock = (
	| result |
	self isOfSameSizeCheck: otherCollection.
	result := self species new: self size.
	1 to: self size do:
		[:index | result at: index put:
		(twoArgBlock
			value: (self at: index)
			value: (otherCollection at: index))].
	^ result
)

----

isAbstract = (
	^self = SequenceableCollection
)

new: newSize streamContents: blockWithArg = (
	| stream originalContents |
	stream := WriteStream on: (self new: newSize).
	blockWithArg value: stream.
	originalContents := stream originalContents.
	originalContents size =  stream position
		ifTrue: [ ^originalContents ]
		ifFalse: [ ^stream contents ]
)

streamContents: blockWithArg = (
		^self new: 100 streamContents: blockWithArg
)

streamContents: blockWithArg limitedTo: sizeLimit = (
	| stream |
	stream := LimitedWriteStream on: (self new: (100 min: sizeLimit)).
	stream setLimit: sizeLimit limitBlock: [^ stream contents].
	blockWithArg value: stream.
	^ stream contents
)

)
