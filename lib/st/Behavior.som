Behavior = Object (

allInstVarNames = (
	<primitive: -1>
	self primitiveFailed
)

allSelectors = (
    "Answer all selectors understood by instances of the receiver"
    ^(Array streamContents: [ :stream |
        self withAllSuperclassesDo: [ :aClass |
            aClass selectorsDo: [ :each |
                stream nextPut: each ] ] ]) asIdentitySet
)

allSuperclasses = (
	"Answer an OrderedCollection of the receiver's and the receiver's
	ancestor's superclasses. The first element is the receiver's immediate
	superclass, followed by its superclass; the last element is Object."
	| temp |
	^ self superclass == nil
		ifTrue: [ OrderedCollection new]
		ifFalse: [temp := self superclass allSuperclasses.
			temp addFirst: self superclass.
			temp]
)

basicNew = (
	<primitive: 70>
	self isVariable ifTrue: [^self basicNew: 0].
	self primitiveFailed
)

basicNew: sizeRequested = (
	<primitive: 71>
	self isVariable ifFalse: [self error: self asString , ' cannot have variable sized instances'].
	self primitiveFailed
)

canUnderstand: selector = (
	"Answer true if the receiver can respond to the message whose selector
	is the argument, false otherwise.  The selector can be in the method dictionary
	of the receiver's class or any of its superclasses."
	(self includesSelector: selector) ifTrue: [^true].
	self superclass == nil ifTrue: [^false].
	^ self superclass canUnderstand: selector
)

deepCopy = (
	"Behavior are shared rather than copied."
	^ self
)

flushCache = (
	<primitive: 89>
	self primitiveFailed
)

hasMethod: aSymbol = (
	self methodArray do: [ :m | m signature = aSymbol ifTrue: [ ^true ] ].
	^false
)

hasMethods = (
	"Answer whether the receiver has any methods in its method dictionary."
	^self methodArray size > 0
)

includesSelector: aSymbol = (
	"Answer whether the message whose selector is the argument is in the
	method dictionary of the receiver's class."
	^self selectors includes: aSymbol
)

inheritsFrom: aClass = (
	| aSuperclass |
	aSuperclass := self superclass.
	[aSuperclass == nil]
		whileFalse:
			[aSuperclass == aClass ifTrue: [^true].
			aSuperclass := aSuperclass superclass].
	^false
)

instSize = (
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>"
	^self allInstVarNames size
)

instVarIndexFor: instVarName ifAbsent: aBlock = (
	"Answer the index of the named instance variable."
	^self allInstVarNames indexOf: instVarName ifAbsent: aBlock
)

isVariable = (
           ^false
)

isBehavior = (
	^true
)

methodArray = (
	<primitive: -1>
	self primitiveFailed
)

new = (
	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."
	^ self basicNew initialize
)

new: sizeRequested = (
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."
	^ (self basicNew: sizeRequested) initialize
)

selectors = (
	^self methodArray collect: [ :item | item signature ]
)

selectorsDo: selectorBlock = (
	"Evaluate selectorBlock for all the message selectors in my method dictionary."
	self selectors do: selectorBlock
)

superclass = (
	<primitive: -1>
	self primitiveFailed
)

withAllSuperclasses = (
	"Answer an OrderedCollection of the receiver and the receiver's
	superclasses. The first element is the receiver,
	followed by its superclass; the last element is Object."
	| temp |
	temp := self allSuperclasses.
	temp addFirst: self.
	^ temp
)

withAllSuperclassesDo: aBlock = (
	"Evaluate the argument, aBlock, for each of the receiver's superclasses."
	aBlock value: self.
	self superclass == nil
		ifFalse: [self superclass withAllSuperclassesDo: aBlock]
)

)
