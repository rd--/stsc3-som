Object = nil (

== other = (
	<primitive: 110>
	self primitiveFailed
)

=  other = (
	^self == other
)

~= anObject = (
	"Answer whether the receiver and the argument do not represent the same object."
	^self = anObject == false
)

~~ anObject = (
	<primitive: 169>
	self == anObject ifTrue: [^false].
	^true
)

-> anObject = (
	^Association basicNew key: self value: anObject
)

asString = (
	^ self printString
)

at: index = (
	<primitive: 60>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [self errorSubscriptBounds: index]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

at: index put: value = (
	<primitive: 61>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index = (
	<primitive: 60>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self basicAt: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index put: value = (
	<primitive: 61>
	index isInteger
		ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]].
	index isNumber
		ifTrue: [^self basicAt: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicSize = (
	<primitive: 62>
	^0
)

class = (
	<primitive: 111>
	self primitiveFailed
)

copy = (
	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy."
	^self shallowCopy postCopy
)

fullPrintString = (
	"Answer a String whose characters are a description of the receiver."
	^ String streamContents: [:s | self printOn: s]
)

identityHash = (
	<primitive: 75>
	self primitiveFailed
)

perform: aSymbol = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: {}
)

perform: selector withArguments: argArray = (
	<primitive: 84>
	^ self perform: selector withArguments: argArray inSuperclass: self class
)

perform: aSymbol withArguments: args = (
	<primitive: 100>
	(selector isSymbol)
		ifFalse: [^ self error: 'selector argument must be a Symbol'].
	(selector numArgs = argArray size)
		ifFalse: [^ self error: 'incorrect number of arguments'].
	(self class == lookupClass or: [self class inheritsFrom: lookupClass])
		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].
	self primitiveFailed
)

postCopy = (
	"self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"
	^ self
)

printOn: aStream = (
	"Append to the argument, aStream, a sequence of characters that  identifies the receiver."
	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title
)

printString = (
	"Answer a String whose characters are a description of the receiver."
	| aStream |
	aStream := WriteStream on: (String new: 16).
	self printOn: aStream.
	^aStream contents
)

shallowCopy = (
	<primitive: 148>
	^self primitiveFailed
)

size = (
	"Primitive. Answer the number of indexable variables in the receiver.
	This value is the same as the largest legal subscript. Essential. See Object
	documentation whatIsAPrimitive."
	<primitive: 62>
	self class isVariable ifFalse: [self errorNotIndexable].
	^ 0
)

species = (
	<primitive: 111>
	^self class
)

storeString = (
	| aStream |
	aStream := WriteStream on: (String new: 16).
	self storeOn: aStream.
	^aStream contents
)

adaptToFloat: rcvr andCompare: selector = (
	^ self adaptToFloat: rcvr andSend: selector
)

adaptToFloat: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

adaptToInteger: rcvr andCompare: selector = (
	^ self adaptToInteger: rcvr andSend: selector
)

adaptToInteger: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

asArray = (
    ^Array with: self
)

asSetElement = (
)

enclosedSetElement = (
)

errorImproperStore = (
	self error: 'Improper store into indexable object'
)

errorNotIndexable = (
	self error: 'Object not indexable'
)

errorSubscriptBounds: index = (
	self error: 'subscript is out of bounds: ' , index asString
)

hash = (
	^self identityHash
)

initialize = (
)

isInteger = (
	^ false
)

isKindOf: aClass = (
	^ self class == aClass or: [ self class inheritsFrom: aClass ]
)

isLiteral = (
	^false
)

isMemberOf: aClass = (
	"Answer whether the receiver is an instance of the class, aClass."
	^self class == aClass
)

isNil = (
	^false
)

isNumber = (
	^false
)

isSymbol = (
	^ false
)

notNil = (
	^true
)

primitiveFailed = (
	('Object>>primitiveFailed: ' , self asString) println.
)

putOn:aStream = (
	^aStream nextPut:self.
)

shouldNotImplement = (
	self error: 'shouldNotImplement'
)

value = (
	^self
)

yourself = (
	^self
)

    "Convenience"
    ifNil: aBlock = (^self)
    ifNotNil: aBlock = (^aBlock value)
    ifNil: noGoBlock ifNotNil: goBlock = (^goBlock value)

    "Printing"
    print = ( self asString print )
    println = ( self print. Smalltalk printNewline )

    "Debugging"
    inspect = primitive
    halt = primitive

    "Error handling"
    error: string = ( '' println. ('Object>>error: ' , string , ' at: ', self class name) println. Smalltalk printContext . ^ nil )
    fatalError: string = ( '' println. ('Object>>fatalError: ' , string) println. Smalltalk exit: 1 )

    "Abstract method support"
    subclassResponsibility = (
        self error: 'This method is abstract and should be overridden'
    )

    "Error recovering"
    doesNotUnderstand: selector arguments: arguments = (
        self error:
            ('Method ' , selector , ' not found in class ' , self class name)
    )

    escapedBlock: block = (
        self error: 'Block has escaped and cannot be executed'
    )

    unknownGlobal: name = ( ^Smalltalk resolve: name )

    "Reflection"
    respondsTo: aSymbol = (
        (self class hasMethod: aSymbol)
            ifTrue:  [ ^true ]
            ifFalse: [ | cls |
                cls := self class superclass.
                [ cls isNil ] whileFalse: [
                    (cls hasMethod: aSymbol)
                        ifTrue:  [ ^true ]
                        ifFalse: [ cls := cls superclass ] ].
                ^ false ]
    )

    perform: aSymbol = primitive
    perform: aSymbol with: anObject = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: { anObject }
    )

    perform: aSymbol inSuperclass: cls = primitive
    perform: aSymbol withArguments: args inSuperclass: cls = primitive

    instVarAt: idx = primitive
    instVarAt: idx put: obj = primitive
    instVarNamed: sym = primitive

)
