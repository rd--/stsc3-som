Object = nil (

== other = (
	<primitive: 110>
	self primitiveFailed
)

=  other = (
	^self == other
)

~= anObject = (
	"Answer whether the receiver and the argument do not represent the same object."
	^self = anObject == false
)

~~ anObject = (
	<primitive: 169>
	self == anObject ifTrue: [^false].
	^true
)

-> anObject = (
	^Association basicNew key: self value: anObject
)

adaptToFloat: rcvr andCompare: selector = (
	^ self adaptToFloat: rcvr andSend: selector
)

adaptToFloat: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

adaptToInteger: rcvr andCompare: selector = (
	^ self adaptToInteger: rcvr andSend: selector
)

adaptToInteger: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

as: aSimilarClass = (
	"Create an object of class aSimilarClass that has similar contents to the receiver."
	^ aSimilarClass newFrom: self
)

assert: aBlock = (
	"Throw an assertion error if aBlock does not evaluates to true."
	aBlock value ifFalse: [self error: 'assertion failed']
)

asArray = (
    ^Array with: self
)

asOrderedCollection = (
	"Answer an OrderedCollection with the receiver as its only element."
	^ OrderedCollection with: self
)

asSetElement = (
)

asString = (
	^ self printString
)

at: index = (
	<primitive: 60>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [self errorSubscriptBounds: index]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

at: index put: value = (
	<primitive: 61>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index = (
	<primitive: 60>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self basicAt: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index put: value = (
	<primitive: 61>
	index isInteger
		ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]].
	index isNumber
		ifTrue: [^self basicAt: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicSize = (
	<primitive: 62>
	^0
)

caseOf: aBlockAssociationCollection = (
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, report an error."
	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]
)

caseOf: aBlockAssociationCollection otherwise: aBlock = (
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, answer the result
	 of evaluating aBlock."
	aBlockAssociationCollection associationsDo:
		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].
	^ aBlock value
)

class = (
	<primitive: 111>
	self primitiveFailed
)

copy = (
	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy."
	^self shallowCopy postCopy
)

doesNotUnderstand: selector = (
	self error: ('Method ' , selector , ' not found in class ' , self class name)
)

doesNotUnderstand: selector arguments: arguments = (
	self error: ('Method ' , selector , ' not found in class ' , self class name)
)

enclosedSetElement = (
)

error: aString = (
        Transcript show: ('Object>>error: ' , aString , ' at: ', self class name); cr.
        Smalltalk printContext.
	Smalltalk halt.
	^ nil
)

errorImproperStore = (
	self error: 'Improper store into indexable object'
)

errorNonIntegerIndex = (
	"Create an error notification that an improper object was used as an index."
	self error: 'only integers should be used as indices'
)

errorNotIndexable = (
	self error: 'Object not indexable'
)

errorSubscriptBounds: index = (
	self error: 'subscript is out of bounds: ' , index asString
)

escapedBlock: block = (
	self error: 'Block has escaped and cannot be executed'
)

fatalError: aString = (
	Transcript show: ('Object>>fatalError: ' , aString); cr.
	Smalltalk exit: 1
)

fullPrintString = (
	"Answer a String whose characters are a description of the receiver."
	^ String streamContents: [:s | self printOn: s]
)

halt = (
	<primitive: -1>
	self primitiveFailed
)

hash = (
	^self identityHash
)

identityHash = (
	<primitive: 75>
	self primitiveFailed
)

ifNil: nilBlock = (
	"Return self, or evaluate the block if I'm == nil (q.v.)"
	^ self
)

ifNotNil: ifNotNilBlock = (
	"Evaluate the block, unless I'm == nil (q.v.)"
	^ ifNotNilBlock cull: self
)

ifNil: ifNilBlock ifNotNil: ifNotNilBlock = (
	^ifNotNilBlock cull: self
)

initialize = (
)

inspect = (
	<primitive: -1>
	self primitiveFailed
)

isArray = (
	^false
)

isCollection = (
	^false
)

isInteger = (
	^ false
)

isInterval = (
	^ false
)

isKindOf: aClass = (
	^ self class == aClass or: [ self class inheritsFrom: aClass ]
)

isLiteral = (
	^false
)

isMemberOf: aClass = (
	"Answer whether the receiver is an instance of the class, aClass."
	^self class == aClass
)

isNil = (
	^false
)

isNumber = (
	^false
)

isStream = (
	^false
)

isString = (
	^ false
)

isSymbol = (
	^ false
)

notNil = (
	^true
)

instVarAt: index = (
	"Primitive. Answer a fixed variable in an object. The numbering of the variables
	 corresponds to the named instance variables, followed by the indexed instance
	 variables. Fail if the index is not an Integer or is not the index of a fixed or
	 indexed variable. Essential. See Object documentation whatIsAPrimitive."
	<primitive: 73>
	self primitiveFailed
)

instVarAt: index put: anObject = (
	"Primitive. Store a value into a fixed variable in an object. The numbering of the
	 variables corresponds to the named instance variables, followed by the indexed
	 instance variables. Fail if the index is not an Integer or is not the index of a fixed
	 or indexed variable. Essential. See Object documentation whatIsAPrimitive."
	<primitive: 74>
	self primitiveFailed
)

literalEqual: other = (
	^ self class == other class and: [self = other]
)

perform: aSymbol = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: {}
)

perform: aSymbol with: anObject = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: { anObject }
)

perform: selector withArguments: argArray = (
	<primitive: 84>
	^ self perform: selector withArguments: argArray inSuperclass: self class
)

perform: selector withArguments: argArray inSuperclass: lookupClass = (
	<primitive: 100>
	(selector isSymbol)
		ifFalse: [^ self error: 'selector argument must be a Symbol'].
	(selector numArgs = argArray size)
		ifFalse: [^ self error: 'incorrect number of arguments'].
	(self class == lookupClass or: [self class inheritsFrom: lookupClass])
		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].
	self primitiveFailed
)

postCopy = (
	"self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"
	^ self
)

primitiveFailed = (
	self error: 'primitiveFailed'
)

primitiveFailed: selector = (
	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."
	self error: selector asString, ' failed'
)

printOn: aStream = (
	"Append to the argument, aStream, a sequence of characters that  identifies the receiver."
	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title
)

printString = (
	"Answer a String whose characters are a description of the receiver."
	| aStream |
	aStream := WriteStream on: (String new: 16).
	self printOn: aStream.
	^aStream contents
)

printStringLimitedTo: limit = (
	| limitedString |
	limitedString := self printString.
	limitedString size < limit ifTrue: [^ limitedString].
	^ (limitedString copyFrom: 1 to: limit) , '...etc...'
)

putOn:aStream = (
	^aStream nextPut:self.
)

shallowCopy = (
	<primitive: 148>
	self primitiveFailed
)

size = (
	"Primitive. Answer the number of indexable variables in the receiver.
	This value is the same as the largest legal subscript. Essential. See Object
	documentation whatIsAPrimitive."
	<primitive: 62>
	self class isVariable ifFalse: [self errorNotIndexable].
	^ 0
)

species = (
	"Answer the preferred class for reconstructing the receiver.  For example,
	collections create new collections whenever enumeration messages such as
	collect: or select: are invoked.  The new kind of collection is determined by
	the species of the original collection.  Species and class are not always the
	same.  For example, the species of Interval is Array."
	<primitive: 111>
	^self class
)

storeString = (
	| aStream |
	aStream := WriteStream on: (String new: 16).
	self storeOn: aStream.
	^aStream contents
)

respondsTo: aSymbol = (
	"Answer whether the method dictionary of the receiver's class contains aSymbol as a message selector."
	^self class canUnderstand: aSymbol
)

shouldNotImplement = (
	self error: 'shouldNotImplement'
)

subclassResponsibility = (
	self error: 'This method is abstract and should be overridden'
)

unknownGlobal: name = (
	^Smalltalk resolve: name
)

value = (
	^self
)

yourself = (
	^self
)

----

)
