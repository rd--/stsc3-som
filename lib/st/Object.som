Object = nil (

at: index = (
	<primitive: 60>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [self errorSubscriptBounds: index]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

at: index put: value = (
	<primitive: 61>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index = (
	<primitive: 60>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self basicAt: index asInteger]
		ifFalse: [self errorNonIntegerIndex]
)

basicAt: index put: value = (
	<primitive: 61>
	index isInteger
		ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]].
	index isNumber
		ifTrue: [^self basicAt: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]
)

basicSize = (
	<primitive: 62>
	^0
)

identityHash = (
	<primitive: 75>
	self primitiveFailed
)

perform: aSymbol = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: {}
)

perform: selector withArguments: argArray = (
	<primitive: 84>
	^ self perform: selector withArguments: argArray inSuperclass: self class
)

perform: aSymbol withArguments: args = (
	<primitive: 100>
	(selector isSymbol)
		ifFalse: [^ self error: 'selector argument must be a Symbol'].
	(selector numArgs = argArray size)
		ifFalse: [^ self error: 'incorrect number of arguments'].
	(self class == lookupClass or: [self class inheritsFrom: lookupClass])
		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].
	self primitiveFailed
)

== other = (
	<primitive: 110>
	self primitiveFailed
)

class = (
	<primitive: 111>
	self primitiveFailed
)

species = (
	<primitive: 111>
	^self class
)

shallowCopy = (
	<primitive: 148>
	^self primitiveFailed
)

~~ anObject = (
	<primitive: 169>
	self == anObject ifTrue: [^false].
	^true
)

-> anObject = (
	^Association basicNew key: self value: anObject
)

adaptToFloat: rcvr andCompare: selector = (
	^ self adaptToFloat: rcvr andSend: selector
)

adaptToFloat: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

adaptToInteger: rcvr andCompare: selector = (
	^ self adaptToInteger: rcvr andSend: selector
)

adaptToInteger: rcvr andSend: selector = (
	^ self adaptToNumber: rcvr andSend: selector
)

asArray = (
    ^Array with: self
)

asSetElement = (
)

enclosedSetElement = (
)

errorImproperStore = (
	self error: 'Improper store into indexable object'
)

errorNotIndexable = (
	self error: 'Object not indexable'
)

errorSubscriptBounds: index = (
	self error: 'subscript is out of bounds: ' , index asString
)

hash = (
	^self identityHash
)

initialize = (
)

isInteger = (
	^ false
)

isNil = (
	^false
)

isNumber = (
	^false
)

notNil = (
	^true
)

primitiveFailed = (
	('Object>>primitiveFailed: ' , self asString) println.
)

value = (
	^self
)

yourself = (
	^self
)

    objectSize = primitive  "size in bytes"

    "Comparing"

    =  other = ( ^self == other )
    <> argument = ( ^(self = argument) not )
    ~= other = (^ (self == other) not )

    "Converting"
    asString = ( ^'instance of ' , (self class) )

    "Convenience"
    ifNil: aBlock = (^self)
    ifNotNil: aBlock = (^aBlock value)
    ifNil: noGoBlock ifNotNil: goBlock = (^goBlock value)

    "Printing"
    print = ( self asString print )
    println = ( self print. Smalltalk printNewline )

    "Debugging"
    inspect = primitive
    halt = primitive

    "Error handling"
    error: string = ( '' println. ('Object>>error: ' , string , ' at: ', self class name) println. ^ nil )
    fatalError: string = ( '' println. ('Object>>fatalError: ' , string) println. Smalltalk exit: 1 )

    "Abstract method support"
    subclassResponsibility = (
        self error: 'This method is abstract and should be overridden'
    )

    "Error recovering"
    doesNotUnderstand: selector arguments: arguments = (
        self error:
            ('Method ' , selector , ' not found in class ' , self class name)
    )

    escapedBlock: block = (
        self error: 'Block has escaped and cannot be executed'
    )

    unknownGlobal: name = ( ^Smalltalk resolve: name )

    "Reflection"
    respondsTo: aSymbol = (
        (self class hasMethod: aSymbol)
            ifTrue:  [ ^true ]
            ifFalse: [ | cls |
                cls := self class superclass.
                [ cls isNil ] whileFalse: [
                    (cls hasMethod: aSymbol)
                        ifTrue:  [ ^true ]
                        ifFalse: [ cls := cls superclass ] ].
                ^ false ]
    )

    perform: aSymbol = primitive
    perform: aSymbol with: anObject = (
	<primitive: 83>
	^ self perform: aSymbol withArguments: { anObject }
    )

    perform: aSymbol inSuperclass: cls = primitive
    perform: aSymbol withArguments: args inSuperclass: cls = primitive

    instVarAt: idx = primitive
    instVarAt: idx put: obj = primitive
    instVarNamed: sym = primitive

)
