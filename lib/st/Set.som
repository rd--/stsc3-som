Set = HashedCollection (

= anObject = (
	self == anObject ifTrue: [ ^true ].
	self species == anObject species ifFalse: [ ^false ].
	self size = anObject size ifFalse: [ ^false ].
	^self allSatisfy: [ :each | anObject includes: each ]
)

add: newObject = (
	| index |
	index := self scanFor: newObject.
	(array at: index) ifNil: [self atNewIndex: index put: newObject asSetElement].
	^ newObject
)

addIfNotPresent: anObject = (
	^self add: anObject
)

asSet = (
	^self
)

collect: aBlock = (
	| newSet |
	newSet := Set new: self size.
	self do: [ :each | newSet add: (aBlock value: each) ].
	^newSet
)

copyWithout: oldElement = (
	"Answer a copy of the receiver that does not contain any elements equal to oldElement."
	^ self copy
		remove: oldElement ifAbsent: [];
		yourself
)

do: aBlock = (
	tally = 0 ifTrue: [ ^self ].
	1 to: array size do: [ :index |
		(array at: index) ifNotNil: [ :element |
			aBlock value: element enclosedSetElement] ]
)

fixCollisionsFrom: start = (
	| element index |
	index := start.
	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [
		| newIndex |
		(newIndex := self scanFor: element enclosedSetElement) = index ifFalse: [
			array at: newIndex put: element.
			array at: index put: nil ] ]
)

ifAbsentAdd: anObject = (
	| index |
	index := self scanFor: anObject.
	(array at: index) ifNil:
		[self
			atNewIndex: index
			put: anObject asSetElement.
		^true].
	^false
)

includes: anObject = (
	(array at: (self scanFor: anObject)) ifNil: [ ^false ] ifNotNil: [ ^true ]
)

like: anObject = (
	"Answer an object in the receiver that is equal to anObject,
	nil if no such object is found. Relies heavily on hash properties"
	^(array at: (self scanFor: anObject)) ifNotNil:[:obj| obj enclosedSetElement]
)

noCheckNoGrowFillFrom: anArray = (
	1 to: anArray size do: [ :index |
		(anArray at: index) ifNotNil: [ :object |
			array
				at: (self scanForEmptySlotFor: object enclosedSetElement)
				put: object ] ]
)

postCopy = (
	super postCopy.
	array := array copy
)

occurrencesOf: anObject = (
	(self includes: anObject) ifTrue: [ ^1 ].
	^0
)

remove: oldObject ifAbsent: aBlock = (
	| index |
	index := self scanFor: oldObject.
	(array at: index) ifNil: [ ^ aBlock value ].
	array at: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^ oldObject
)

scanFor: anObject = (
	| index start size |
	index := start := anObject hash \\ (size := array size) + 1.
	[
		| element |
		((element := array at: index) == nil or: [ anObject = element enclosedSetElement ]) ifTrue: [ ^index ].
		(index := index \\ size + 1) = start
	] whileFalse.
	self errorNoFreeSpace
)

select: aBlock = (
	| newCollection |
	newCollection := self copyEmpty.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^newCollection
)

----------------------------

newFrom: aCollection = (
	| newCollection |
	newCollection := self new: aCollection size.
	newCollection addAll: aCollection.
	^ newCollection
)

)
