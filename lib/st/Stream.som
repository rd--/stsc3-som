Stream = Object (

any: numberOfElements = (
	"See Collection protocol."
	^ self next: numberOfElements
)

atEnd = (
	self subclassResponsibility
)

contents = (
	self subclassResponsibility
)

do: aBlock = (
	[ self atEnd ] whileFalse: [ aBlock value: self next ]
)

flatten = (
	^ Generator on: [:g |
		[self atEnd] whileFalse: [
			self next in: [:object |
				((object isCollection and: [object isString not]) or: [object isStream])
					ifFalse: [g yield: object]
					ifTrue: [object flatten do: [:each | g yield: each]]]]]
)

isStream = (
	"Return true if the receiver responds to the stream protocol"
	^true
)

next = (
	self subclassResponsibility
)

next: anInteger = (
	| aCollection |
	aCollection := OrderedCollection new.
	anInteger timesRepeat: [ aCollection addLast: self next ].
	^aCollection
)

next: anInteger put: anObject = (
	anInteger timesRepeat: [ self nextPut: anObject ] .
	^anObject
)

nextMatchAll: aColl = (
    "Answer true if next N objects are the ones in aColl,
     else false.  Advance stream of true, leave as was if false."
    | save |
    save := self position.
    aColl do: [:each |
       (self next) = each ifFalse: [
            self position: save.
            ^ false]
        ].
    ^ true
)

nextMatchFor: anObject = (
	^anObject = self next
)

nextPut: anObject = (
	self subclassResponsibility
)

nextPutAll: aCollection = (
	aCollection do: [ :v | self nextPut: v ] .
	^aCollection
)

nextSatisfy: aBlock = (
	self do: [:each | (aBlock value: each) ifTrue: [^ each]].
	self error: 'No object could satisfy the block'.
)

readInto: aCollection startingAt: startIndex count: n = (
	"Read n objects into the given collection.
	Return number of elements that have been read."
	| obj |
	0 to: n - 1 do: [:i |
		obj := self next ifNil: [ ^i ].
		aCollection at: startIndex + i put: obj].
	^n
)

reject: aBlock = (
	^ self select: [:element | (aBlock value: element) == false]
)

select: block = (
	^ Generator on: [:g |
		[self atEnd] whileFalse: [
			self next
				ifNil: [g yield: nil]
				ifNotNil: [:object |
					(block value: object)
						ifTrue: [g yield: object]]]]
)

take: maxNumberOfElements = (
	"See Collection protocol."
	^ self any: maxNumberOfElements
)

upToEnd = (
	"Answer the remaining elements in the stream."
	| elements |
	elements := OrderedCollection new.
	[self atEnd] whileFalse: [
		elements add: self next].
	^ elements
)

----------------------------

new = (
	self error: 'Streams are created with on: and with:'
)

)
