SmallInteger = Integer (

+ aNumber = (
	<primitive: 1>
	^ aNumber adaptToInteger: self andSend: #+
)

- aNumber = (
	<primitive: 2>
	^ aNumber adaptToInteger: self andSend: #-
)

< aNumber = (
	<primitive: 3>
	^ aNumber adaptToInteger: self andCompare: #<
)

> aNumber = (
	<primitive: 4>
	^ aNumber adaptToInteger: self andCompare: #>
)

<= aNumber = (
	<primitive: 5>
	^ aNumber adaptToInteger: self andCompare: #<=
)

>= aNumber = (
	<primitive: 6>
	^ aNumber adaptToInteger: self andCompare: #>=
)

= aNumber = (
	<primitive: 7>
	^ aNumber adaptToInteger: self andCompare: #=
)

~= aNumber = (
	<primitive: 8>
	^ aNumber adaptToInteger: self andCompare: #~=
)

* aNumber = (
	<primitive: 9>
	^ aNumber adaptToInteger: self andSend: #*
)

/ aNumber = (
	<primitive: 10>
	^ self asFloat / aNumber
)

asFloat = (
	<primitive: 40>
	self primitiveFailed
)

adaptToFloat: rcvr andSend: selector = (
	^ rcvr perform: selector with: self asFloat
)

adaptToFloat: rcvr andCompare: selector = (
	^ rcvr perform: selector with: self asFloat
)

/ argument = primitive
// argument = primitive
% argument = primitive "modulo with sign of divisor"
rem: argument=primitive "modulo with sign of dividend"
& argument = primitive
<< argument = primitive
>>> argument= primitive
bitXor: argument = primitive
sqrt = primitive

raisedTo: exponent = (
	"Raise the receiver to the given exponent.
	 Currently only positive integer exponents
	 are fully supported."
	| output |
	output := 1.
	exponent asInteger
	  timesRepeat: [ output := output * self ].
	^ output
)

"Random numbers"
atRandom = primitive

"Comparing"
== argument = ( ^self = argument )

asString = primitive
as32BitSignedValue = primitive " returns an int, with the value that a signed 32-bit integer would have"
as32BitUnsignedValue = primitive " returns an int, with the value that a unsigned 32-bit integer would have"

hashcode = ( ^self )

----

fromString: aString = primitive

)
