SmallInteger = Integer (

+ aNumber = (
	<primitive: 1>
	^ aNumber adaptToInteger: self andSend: #+
)

- aNumber = (
	<primitive: 2>
	^ aNumber adaptToInteger: self andSend: #-
)

< aNumber = (
	<primitive: 3>
	^ aNumber adaptToInteger: self andCompare: #<
)

> aNumber = (
	<primitive: 4>
	^ aNumber adaptToInteger: self andCompare: #>
)

<= aNumber = (
	<primitive: 5>
	^ aNumber adaptToInteger: self andCompare: #<=
)

>= aNumber = (
	<primitive: 6>
	^ aNumber adaptToInteger: self andCompare: #>=
)

= aNumber = (
	<primitive: 7>
	^super = aNumber
)

~= aNumber = (
	<primitive: 8>
	^ aNumber adaptToInteger: self andCompare: #~=
)

* aNumber = (
	<primitive: 9>
	^ aNumber adaptToInteger: self andSend: #*
)

/ aNumber = (
	<primitive: 10>
	^ self asFloat / aNumber
)

\\ aNumber = (
	<primitive: 11>
	^ super \\ aNumber
)

// aNumber = (
	<primitive: 12>
	^ super // aNumber
)

bitAnd: arg = (
	<primitive: 14>
        self primitiveFailed
)

bitOr: arg  = (
	<primitive: 15>
        self primitiveFailed
)

bitXor: arg  = (
	<primitive: 16>
        self primitiveFailed
)

bitShift: arg = (
	<primitive: 17>
	self = 0 ifTrue: [^self].
        self primitiveFailed
)

asFloat = (
	<primitive: 40>
	self primitiveFailed
)

asString = (
	<primitive: -1>
        self primitiveFailed
)

atRandom = (
	<primitive: -1>
        self primitiveFailed
)

adaptToFloat: rcvr andSend: selector = (
	^ rcvr perform: selector with: self asFloat
)

adaptToFloat: rcvr andCompare: selector = (
	^ rcvr perform: selector with: self asFloat
)

even = (
	^(self bitAnd: 1) = 0
)

gcd: anInteger  = (
	| n m |
	anInteger denominator = 1 ifFalse: [^anInteger gcd: self].
	n := self.
	m := anInteger.
	[n = 0]
		whileFalse:
			[n := m \\ (m := n)].
	^ m abs
)

hash = (
	^self
)

highBit = (
	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].
	^ self highBitOfPositiveReceiver
)

highBitOfByte = (
	^ #(0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8) at: self + 1
)

highBitOfPositiveReceiver = (
	| shifted bitNo |
	shifted := self.
	bitNo := 0.
	[shifted < 65536]
		whileFalse:
			[shifted := shifted bitShift: -16.
			bitNo := bitNo + 16].
	shifted < 256
		ifFalse:
			[shifted := shifted bitShift: -8.
			bitNo := bitNo + 8].
	^bitNo + shifted highBitOfByte
)

identityHash = (
	^self
)

odd = (
	^(self bitAnd: 1) = 1
)

printOn: aStream = (
	^self asString putOn: aStream
)

shallowCopy = (
)

sqrt = (
	| floatResult integerResult |
	self negative ifTrue: [ ^ DomainError signal: 'sqrt undefined for number less than zero.' ].
	floatResult := self asFloat sqrt.
	integerResult := floatResult truncated.
	integerResult * integerResult = self ifTrue: [^integerResult].
	^floatResult
)

----

fromString: aString = (
	<primitive: -1>
        self primitiveFailed
)

)
