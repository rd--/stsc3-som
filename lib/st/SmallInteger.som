SmallInteger = Integer (

+ aNumber = (
	<primitive: 1>
	^ aNumber adaptToInteger: self andSend: #+
)

- aNumber = (
	<primitive: 2>
	^ aNumber adaptToInteger: self andSend: #-
)

< aNumber = (
	<primitive: 3>
	^ aNumber adaptToInteger: self andCompare: #<
)

> aNumber = (
	<primitive: 4>
	^ aNumber adaptToInteger: self andCompare: #>
)

<= aNumber = (
	<primitive: 5>
	^ aNumber adaptToInteger: self andCompare: #<=
)

>= aNumber = (
	<primitive: 6>
	^ aNumber adaptToInteger: self andCompare: #>=
)

= aNumber = (
	<primitive: 7>
	^super = aNumber
)

~= aNumber = (
	<primitive: 8>
	^ aNumber adaptToInteger: self andCompare: #~=
)

* aNumber = (
	<primitive: 9>
	^ aNumber adaptToInteger: self andSend: #*
)

/ aNumber = (
	<primitive: 10>
	^ self asFloat / aNumber
)

\\ aNumber = (
	<primitive: 11>
	^ super \\ aNumber
)

// aNumber = (
	<primitive: 12>
	^ super // aNumber
)

bitAnd: arg = (
	<primitive: 14>
	self >= 0 ifTrue: [^arg bitAnd: self].
	^arg < 0
		ifTrue: [(arg bitInvert bitOr: self bitInvert) bitInvert]
		ifFalse: [arg bitClear: self bitInvert]
)

bitOr: arg  = (
	<primitive: 15>
	self >= 0 ifTrue: [^ arg bitOr: self].
	^ arg < 0
		ifTrue: [(self bitInvert bitAnd: arg bitInvert) bitInvert]
		ifFalse: [(self bitInvert bitClear: arg) bitInvert]
)

bitShift: arg = (
	<primitive: 17>
	self = 0 ifTrue: [^self].
	self > 0 ifTrue: [^ super bitShift: arg].
	^ arg >= 0
		ifTrue: [(self negated bitShift: arg) negated]
		ifFalse: [(self bitInvert bitShift: arg) bitInvert]
)

bitXor: arg  = (
	<primitive: 16>
	self >= 0 ifTrue: [^ arg bitXor: self].
	^ arg < 0
		ifTrue: [self bitInvert bitXor: arg bitInvert]
		ifFalse: [(self bitInvert bitXor: arg) bitInvert]
)

asFloat = (
	<primitive: 40>
	self primitiveFailed: #asFloat
)

asString = (
	<primitive: -1>
        self primitiveFailed: #asString
)

atRandom = (
	<primitive: -1>
        self primitiveFailed: #atRandom
)

adaptToFloat: rcvr andSend: selector = (
	^ rcvr perform: selector with: self asFloat
)

adaptToFloat: rcvr andCompare: selector = (
	^ rcvr perform: selector with: self asFloat
)

even = (
	^(self bitAnd: 1) = 0
)

gcd: anInteger  = (
	| n m |
	anInteger denominator = 1 ifFalse: [^anInteger gcd: self].
	n := self.
	m := anInteger.
	[n = 0]
		whileFalse:
			[n := m \\ (m := n)].
	^ m abs
)

hash = (
	^self
)

hashMultiply = (
	"This is a multiplication by 1664525 mod 2^28 written to avoid overflowing into large integers.
	 The primitive is able to perform the operation with modulo arihmetic."
	<primitive: 159>
	| low |
	low := self bitAnd: 16383.
	^(9741 * low + ((9741 * (self bitShift: -14) + (101 * low) bitAnd: 16383) * 16384))
			bitAnd: 268435455
)

highBit = (
	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].
	^ self highBitOfPositiveReceiver
)

highBitOfByte = (
	^ #(0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8) at: self + 1
)

highBitOfPositiveReceiver = (
	| shifted bitNo |
	shifted := self.
	bitNo := 0.
	[shifted < 65536]
		whileFalse:
			[shifted := shifted bitShift: -16.
			bitNo := bitNo + 16].
	shifted < 256
		ifFalse:
			[shifted := shifted bitShift: -8.
			bitNo := bitNo + 8].
	^bitNo + shifted highBitOfByte
)

identityHash = (
	^self
)

odd = (
	^(self bitAnd: 1) = 1
)

printOn: aStream = (
	^self asString putOn: aStream
)

shallowCopy = (
)

sqrt = (
	| floatResult integerResult |
	self negative ifTrue: [ ^ DomainError signal: 'sqrt undefined for number less than zero.' ].
	floatResult := self asFloat sqrt.
	integerResult := floatResult truncated.
	integerResult * integerResult = self ifTrue: [^integerResult].
	^floatResult
)

sqrtFloor = (
	"See super. Use asFloat sqrt which is known to be exactly rounded.
	Adjust the result in case self asFloat is inexact.
	An example why it is necessary with 60 bits SmallInteger is:
		| i |
		i := (1<<28-1) squared - 1.
		i asFloat sqrt truncated squared <= i.
	What happens is that i and and next perfect square above i, s^2
	are rounded to the same Float f >= s^2.
	In other words, asFloat did cross the next perfect square boundary.
	The guess is at most off by 1, because the next next perfect square is:
		(s + 1) squared = (2*s + s squared + 1)
	s squared has at most 60 bits, and 2*s has 31 bits in this case,
	s squared highBit - (2*s) highBit < Float precision,
	so we are sure that next next perfect square is a different Float."
	| guess |
	guess := self asFloat sqrt truncated.
	guess * guess > self ifTrue: [^guess - 1].
	^guess
)

----

fromString: aString = (
	<primitive: -1>
        self primitiveFailed: #fromString:
)

)
