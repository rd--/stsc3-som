Bag = Collection (

| contents |

add: newObject = (
	^self add: newObject withOccurrences: 1
)

add: newObject withOccurrences: anInteger = (
	(self includes: newObject)
		ifTrue: [contents at: newObject put: anInteger + (contents at: newObject)]
		ifFalse: [contents at: newObject put: anInteger].
	^newObject
)

at: index = (
	self errorNotKeyed
)

at: index put: anObject = (
	self errorNotKeyed
)

do: aBlock = (
	contents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]
)

includes: anObject = (
	^contents includesKey: anObject
)

occurrencesOf: anObject = (
	(self includes: anObject)
		ifTrue: [^contents at: anObject]
		ifFalse: [^0]
)

postCopy = (
	super postCopy.
	contents := contents copy
)

setContents: aDictionary = (
	contents := aDictionary
)

setDictionary = (
	contents := Dictionary new
)

size = (
	| tally |
	tally := 0.
	contents do: [:each | tally := tally + each].
	^tally
)

sortedCounts = (
	| counts |
	counts := SortedCollection sortBlock: [:x :y | x >= y].
	contents associationsDo:
		[:assn |
		counts add: (Association key: assn value value: assn key)].
	^ counts
)

sortedElements = (
	| elements |
	elements := SortedCollection new.
	contents associationsDo: [:assn | elements add: assn].
	^ elements
)

remove: oldObject ifAbsent: exceptionBlock = (
	| count |
	(self includes: oldObject)
		ifTrue: [(count := contents at: oldObject) = 1
				ifTrue: [contents removeKey: oldObject]
				ifFalse: [contents at: oldObject put: count - 1]]
		ifFalse: [^exceptionBlock value].
	^oldObject
)

----------------------------

contentsClass = (
	^Dictionary
)

new = (
	^super new setDictionary
)

new: nElements = (
	^ super new setContents: (self contentsClass new: nElements)
)

newFrom: aCollection = (
	^ self withAll: aCollection
)

)
