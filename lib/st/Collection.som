Collection = (

* arg = (
	^ arg adaptToCollection: self andSend: #*
)

+ arg = (
	^ arg adaptToCollection: self andSend: #+
)

- arg = (
	^ arg adaptToCollection: self andSend: #-
)

/ arg = (
	^ arg adaptToCollection: self andSend: #/
)

adaptToCollection: rcvr andSend: selector = (
	rcvr isSequenceable & self isSequenceable ifFalse:
		[self error: 'Only sequenceable collections may be combined arithmetically'].
	^ rcvr with: self collect:
		[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]
)

adaptToNumber: rcvr andSend: selector = (
	^ self collect: [:element | rcvr perform: selector with: element]
)

addAll: aCollection = (
	aCollection do: [:each | self add: each].
	^ aCollection
)

allSatisfy: aBlock = (
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."
	self do: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true
)

any: numberOfElements = (
	^ self any: numberOfElements as: self species
)

any: numberOfElements as: aClass = (
	"Enumerate this colleciton and return the specified number of elements. Signals an error if this collection has not enough elements."
	| index result |
	index := 0.
	result := aClass new: numberOfElements.
	result fillFrom: self with: [:each |
		(index := index + 1) > numberOfElements
			ifTrue: [^ result]
			ifFalse: [each]].
	index = numberOfElements
		ifFalse: [self error: 'Not enough elements in this collection.'].
	^ result
)

anyOne = (
	self do: [:each | ^ each].
	self errorEmptyCollection
)

anySatisfy: aBlock = (
	self do: [:each | (aBlock value: each) ifTrue: [^ true]].
	^ false
)

asArray = (
	| array index |
	array := Array new: self size.
	index := 0.
	self do: [:each | array at: (index := index + 1) put: each].
	^ array
)

asBag = (
	"Answer a Bag whose elements are the elements of the receiver."
	^ Bag withAll: self
)

asCollection = (
	^ self
)

asIdentitySet = (
	| answer |
	answer := IdentitySet new: self size.
	answer addAll: self.
	^ answer
)

asOrderedCollection = (
	"Answer an OrderedCollection whose elements are the elements of the
	receiver. The order in which elements are added depends on the order
	in which the receiver enumerates its elements. In the case of unordered
	collections, the ordering is not necessarily the same for multiple
	requests for the conversion."
	^ self as: OrderedCollection
)

asSet = (
	^ Set withAll: self
)

associationsDo: aBlock = (
	"Evaluate aBlock for each of the receiver's elements (key/value
	associations).  If any non-association is within, the error is not caught now,
	but later, when a key or value message is sent to it."
	self do: aBlock
)

atRandom = (
	"Answer a random element of the receiver.  Uses the process-local random number generator. Causes an error if self has no elements."
	^self atRandom: Random
)

atRandom: aGenerator = (
	"Answer a random element of the receiver. Uses aGenerator which
	should be kept by the user in a variable and used every time. Use
	this instead of #atRandom for better uniformity of random numbers because
	only you use the generator. Causes an error if self has no elements."
	| randomIndex index |
	self emptyCheck.
	randomIndex := aGenerator nextInt: self size.
	index := 1.
	self do: [ :each |
		index = randomIndex ifTrue: [ ^each ].
		index := index + 1 ]
)

average = (
	^ self sum / self size
)

ceiling = (
	^ self collect: [:a | a ceiling]
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new.
	self do: [:each | newCollection add: (aBlock value: each)].
	^ newCollection
)

collect: aBlock as: aClass = (
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Collect the resulting values into an instance of aClass. Answer the resulting collection."
	^(aClass new: self size) fillFrom: self with: aBlock
)

contains: aBlock = (
	^self anySatisfy: aBlock
)

detect: aBlock = (
	^ self
		detect: aBlock
		ifFound: [:element | element]
		ifNone: [self errorNotFound: aBlock]
)

detect: aBlock ifFound: foundBlock = (
	^ self
		detect: aBlock
		ifFound: foundBlock
		ifNone: nil
)

detect: aBlock ifFound: foundBlock ifNone: exceptionBlock = (
	self do: [:each | (aBlock value: each) ifTrue: [^ foundBlock value: each]].
	^ exceptionBlock value
)

detect: aBlock ifNone: exceptionBlock = (
	^ self
		detect: aBlock
		ifFound: [:element | element]
		ifNone: exceptionBlock
)

difference: aCollection = (
	^ self reject: [:each | aCollection includes: each]
)

do: aBlock = (
	self subclassResponsibility
)

do: elementBlock separatedBy: separatorBlock = (
	| beforeFirst |
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
)

emptyCheck = (
	self isEmpty ifTrue: [self errorEmptyCollection]
)

errorDifferentSize = (
	self error: 'otherCollection must be the same size'
)

errorEmptyCollection = (
	self error: 'this collection is empty'
)

errorNotFound: anObject = (
	{self . anObject} error: 'anObject was not found in this collection'
)

fillFrom: aCollection with: aBlock = (
	"Evaluate aBlock with each of aCollections's elements as the argument.
	Collect the resulting values into self. Answer self."
	aCollection do: [ :each |
		self add: (aBlock value: each) ]
)

floor = (
	^ self collect: [:a | a floor]
)

histogramOf: aBlock = (
	^ self collect: aBlock as: Bag
)

ifEmpty: aBlock = (
	"Evaluate aBlock if I'm empty, return myself otherwise."
	self isEmpty ifTrue: [^ aBlock value].
)

ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock = (
	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise. If the notEmptyBlock has an argument, evalualte it with myself as its argument. See also #ifEmpty:ifNotEmptyDo:."
	self isEmpty ifTrue: [^ emptyBlock value].
	^ notEmptyBlock cull: self
)

ifEmpty: emptyBlock ifNotEmptyDo: notEmptyBlock = (
	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"
	"Evaluate the notEmptyBlock with the receiver as its argument"
	self isEmpty ifTrue: [ ^emptyBlock value ].
	^notEmptyBlock value: self
)

ifNotEmpty: aBlock = (
	"Evaluate aBlock if I'm not empty, return myself otherwise. If aBlock has an argument, evaluate it with myself as its argument. See also #ifNotEmptyDo:."
	self isEmpty ifFalse: [^ aBlock cull: self].
)

ifNotEmptyDo: aBlock = (
	"Evaluate the given block with the receiver as its argument."
	self isEmpty ifFalse: [^ aBlock value: self].
)

ifNotEmptyDo: notEmptyBlock ifEmpty: emptyBlock = (
	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise
	Evaluate the notEmptyBlock with the receiver as its argument"
	self isEmpty ifFalse: [ ^notEmptyBlock value: self ].
	^emptyBlock value
)

includes: anObject = (
	"Answer whether anObject is one of the receiver's elements."
	^ self anySatisfy: [:each | each = anObject]
)

includesAllOf: aCollection = (
	"Answer whether all the elements of aCollection are in the receiver."
	aCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].
	^ true
)

includesAnyOf: aCollection = (
	"Answer whether any element of aCollection is one of the receiver's elements."
	aCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].
	^ false
)

inject: thisValue into: binaryBlock = (
	| nextValue |
	nextValue := thisValue.
	self do: [:each | nextValue := binaryBlock value: nextValue value: each].
	^nextValue
)

intersection: aCollection = (
	^ self select: [:each | aCollection includes: each]
)

isCollection = (
	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"
	^true
)

isEmpty = (
	^self size = 0
)

isOfSameSizeCheck: otherCollection = (
	otherCollection size = self size ifFalse: [self errorDifferentSize]
)

isSequenceable = (
	^ false
)

log2 = (
	^ self collect: [:each | each log2]
)

max = (
	^ self inject: self anyOne into: [:max :each | max max: each]
)

min = (
	"Answer the minimum value in the collection.  The collection must be non-empty and contain 'compatible' Magnitudes (eg: don't try this with a collection containing both Dates and Characters)."
	^ self inject: self anyOne into: [:min :each | min min: each]
)

minMax = (
	"Scans for minimum and maximum in one pass returning the results as a two-element array"
	| min max |
	min := max := self anyOne.
	self do: [ :each |
		min := min min: each.
		max := max max: each ].
	^ Array with: min with: max
)

occurrencesOf: anObject = (
	"Answer how many of the receiver's elements are equal to anObject."
	| tally |
	tally := 0.
	self do: [:each | anObject = each ifTrue: [tally := tally + 1]].
	^tally
)

product = (
    "All of my elements multiplied togeather."
    ^self inject: 1 into: [ :accumulator :item | accumulator * item ]
)

reciprocal = (
	"Return the reciever full of reciprocated elements"
	^ self collect: [:a | a reciprocal]
)

reduce: binaryBlock = (
	| first nextValue |
	first := true.
	self do: [ :each |
		first
			ifTrue: [ nextValue := each. first := false ]
			ifFalse: [ nextValue := binaryBlock value: nextValue value: each ] ].
	first ifTrue: [ self errorEmptyCollection ].
	^nextValue
)

reject: aBlock = (
	^self select: [:element | (aBlock value: element) == false]
)

reject: rejectBlock thenDo: doBlock = (
	^ (self reject: rejectBlock) do: doBlock
)

remove: oldObject = (
	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]
)

remove: oldObject ifAbsent: anExceptionBlock = (
	self subclassResponsibility
)

removeAll: aCollection = (
	aCollection == self ifTrue: [^self removeAll].
	aCollection do: [:each | self remove: each].
	^ aCollection
)

roundTo: quantum= (
	^self collect: [ :ea | ea roundTo: quantum ]
)

select: aBlock = (
	| newCollection |
	newCollection := self species new.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^newCollection
)

select: selectBlock thenCollect: collectBlock = (
	^ (self select: selectBlock) collect: collectBlock
)

select: selectBlock thenDo: doBlock = (
	^ (self select: selectBlock) do: doBlock
)

sign = (
	^self collect: [:each | each sign]
)

sqrt = (
	^ self collect: [:each | each sqrt]
)

sum = (
	^self reduce: [:a :b| a + b]
)

take: maxNumberOfElements = (
	"Returns maxNumberOfElements as a new collection or less if the collection is not large enough."
	^ self any: (maxNumberOfElements min: self size)
)

truncated = (
	^ self collect: [:a | a truncated]
)

union: aCollection = (
	| answer |
        answer := self asSet addAll: aCollection.
        ^ answer
)

----

isAbstract = (
	^self = Collection
)

ofSize: n = (
	^ self new: n
)

with: anObject = (
	"Answer an instance of me containing anObject."
	| answer |
	answer := self new.
	answer add: anObject.
	^ answer
)

with: firstObject with: secondObject = (
	"Answer an instance of me containing the two arguments as elements."
	^ self new
		add: firstObject;
		add: secondObject;
		yourself
)

with: firstObject with: secondObject with: thirdObject = (
	"Answer an instance of me containing the three arguments as elements."
	^ self new
		add: firstObject;
		add: secondObject;
		add: thirdObject;
		yourself
)

withAll: aCollection = (
	"Create a new collection containing all the elements from aCollection."
	^ (self new: aCollection size)
		addAll: aCollection;
		yourself
)

)
