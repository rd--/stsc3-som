Collection = (

adaptToCollection: rcvr andSend: selector = (
	rcvr isSequenceable & self isSequenceable ifFalse:
		[self error: 'Only sequenceable collections may be combined arithmetically'].
	^ rcvr with: self collect:
		[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]
)

adaptToNumber: rcvr andSend: selector = (
	^ self collect: [:element | rcvr perform: selector with: element]
)

addAll: aCollection = (
	aCollection do: [:each | self add: each].
	^ aCollection
)

anySatisfy: aBlock = (
	self do: [:each | (aBlock value: each) ifTrue: [^ true]].
	^ false
)

asArray = (
	| array index |
	array := Array new: self size.
	index := 0.
	self do: [:each | array at: (index := index + 1) put: each].
	^ array
)

asCollection = (
	^ self
)

asSet = (
	^ Set withAll: self
)

associationsDo: aBlock = (
	self do: aBlock
)

average = (
	^ self sum / self size
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new.
	self do: [:each | newCollection add: (aBlock value: each)].
	^ newCollection
)

contains: aBlock = (
	^self anySatisfy: aBlock
)

detect: aBlock = (
	^ self
		detect: aBlock
		ifFound: [:element | element]
		ifNone: [self errorNotFound: aBlock]
)

detect: aBlock ifFound: foundBlock ifNone: exceptionBlock = (
	self do: [:each | (aBlock value: each) ifTrue: [^ foundBlock value: each]].
	^ exceptionBlock value
)

detect: aBlock ifNone: exceptionBlock = (
	^ self
		detect: aBlock
		ifFound: [:element | element]
		ifNone: exceptionBlock
)

difference: aCollection = (
	^ self reject: [:each | aCollection includes: each]
)

do: aBlock = (
	self subclassResponsibility
)

do: elementBlock separatedBy: separatorBlock = (
	| beforeFirst |
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
)

emptyCheck = (
	self isEmpty ifTrue: [self errorEmptyCollection]
)

errorDifferentSize = (
	self error: 'otherCollection must be the same size'
)

errorEmptyCollection = (
	self error: 'this collection is empty'
)

includes: anObject = (
	"Answer whether anObject is one of the receiver's elements."
	^ self anySatisfy: [:each | each = anObject]
)

inject: thisValue into: binaryBlock = (
	| nextValue |
	nextValue := thisValue.
	self do: [:each | nextValue := binaryBlock value: nextValue value: each].
	^nextValue
)

intersection: aCollection = (
	^ self select: [:each | aCollection includes: each]
)

isEmpty = (
	^self size = 0
)

isOfSameSizeCheck: otherCollection = (
	otherCollection size = self size ifFalse: [self errorDifferentSize]
)

isSequenceable = (
	^ false
)

product = (
    "All of my elements multiplied togeather."
    ^self inject: 1 into: [ :accumulator :item | accumulator * item ]
)

reduce: binaryBlock = (
	| first nextValue |
	first := true.
	self do: [ :each |
		first
			ifTrue: [ nextValue := each. first := false ]
			ifFalse: [ nextValue := binaryBlock value: nextValue value: each ] ].
	first ifTrue: [ self errorEmptyCollection ].
	^nextValue
)

reject: aBlock = (
	^self select: [:element | (aBlock value: element) == false]
)

reject: rejectBlock thenDo: doBlock = (
	^ (self reject: rejectBlock) do: doBlock
)

remove: oldObject = (
	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]
)

remove: oldObject ifAbsent: anExceptionBlock = (
	self subclassResponsibility
)

removeAll: aCollection = (
	aCollection == self ifTrue: [^self removeAll].
	aCollection do: [:each | self remove: each].
	^ aCollection
)

select: aBlock = (
	| newCollection |
	newCollection := self species new.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^newCollection
)

select: selectBlock thenCollect: collectBlock = (
	^ (self select: selectBlock) collect: collectBlock
)

select: selectBlock thenDo: doBlock = (
	^ (self select: selectBlock) do: doBlock
)

sqrt = (
	^ self collect: [:each | each sqrt]
)

sum = (
	^self reduce: [:a :b| a + b]
)

union: aCollection = (
	| answer |
        answer := self asSet addAll: aCollection.
        ^ answer
)

----

withAll: aCollection = (
	| answer |
	answer := (self new: aCollection size) addAll: aCollection.
	^ answer
)

)
