PositionableStream = Stream (

| collection position readLimit |

atEnd = (
	<primitive: 67>
	^position >= readLimit
)

back = (
	"Go back one element and return it."
	self position = 0 ifTrue: [self errorCantGoBack].
	self skip: -1.
	^ self peek
)

backUpTo: subCollection = (
	"Back up the position to the subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter."
	| pattern startMatch |
	pattern := ReadStream on: subCollection reversed.
	startMatch := nil.
	[pattern atEnd] whileFalse:
		[self position = 0 ifTrue: [^ false].
		self skip: -1.
		(self next) = (pattern next)
			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch-1.
						startMatch := nil]].
		self skip: -1].
	self position: startMatch.
	^ true
)

basicUpTo: anObject = (
	"Answer a subcollection from the current access position to the
	occurrence (if any, but not inclusive) of anObject in the receiver. If
	anObject is not in the collection, answer the entire rest of the receiver."
	| newStream element |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd or: [(element := self next) = anObject]]
		whileFalse: [newStream nextPut: element].
	^newStream contents
)

collectionSpecies = (
	"Answer the species of collection into which the receiver can stream"
	^ collection species
)

contents = (
	"Answer with a copy of my collection from 1 to readLimit."
	^collection copyFrom: 1 to: readLimit
)

errorCantGoBack = (
	self error: 'Can''t Go Back'
)

isEmpty = (
	"Returns true if both the set of past and future sequence values of the receiver are empty. Otherwise returns false"
	^ self atEnd and: [position = 0]
)

last = (
	"Return the element that was read last"
	^ collection at: position
)

match: subCollection = (
	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."
	| pattern startMatch |
	pattern := ReadStream on: subCollection.
	startMatch := nil.
	[pattern atEnd] whileFalse:
		[self atEnd ifTrue: [^ false].
		(self next) = (pattern next)
			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch.
						startMatch := nil]]].
	^ true
)

next: anInteger = (
	| newArray |
	newArray := self contents species new: anInteger.
	1 to: anInteger do: [:index | newArray at: index put: self next].
	^newArray
)

next: anInteger putAll: aCollection startingAt: startIndex = (
	"Store the next anInteger elements from the given collection."
	startIndex to: startIndex + anInteger - 1 do: [ :index |
		self nextPut: (aCollection at: index) ].
	^aCollection
)

nextLine = (
	"Answer next line (may be empty) without line end delimiters, or nil if at end.
	Let the stream positioned after the line delimiter(s).
	Handle a zoo of line delimiters CR, LF, or CR-LF pair"
	self atEnd ifTrue: [^nil].
	^self upToAnyOf: CharacterSet crlf do: [:char | char = Character cr ifTrue: [self peekFor: Character lf]]
)

on: aCollection = (
	collection := aCollection.
	readLimit := aCollection size.
	position := 0.
	self reset
)

originalContents = (
	"Answer the receiver's actual contents collection, NOT a copy.  1/29/96 sw"
	^ collection
)

peek = (
	"Answer what would be returned if the message next were sent to the
	receiver. If the receiver is at the end, answer nil."
	| nextObject |
	self atEnd ifTrue: [^nil].
	nextObject := self next.
	position := position - 1.
	^nextObject
)

peekFor: anObject = (
	"Answer false and do not move over the next element if it is not equal to
	the argument, anObject, or if the receiver is at the end. Answer true
	and increment the position for accessing elements, if the next element is
	equal to anObject."

	self atEnd ifTrue: [^false].
	"gobble it if found"
	self next = anObject ifTrue: [ ^true ].
	position := position - 1.
	^false
)

position = (
	^position
)

position: anInteger = (
	anInteger >= 0 & (anInteger <= readLimit)
		ifTrue: [position := anInteger]
		ifFalse: [self positionError]
)

positionError = (
	self error: 'Attempt to set the position of a PositionableStream out of bounds'
)

positionOfSubCollection: subCollection ifAbsent: exceptionBlock = (
	"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.
	If no such match is found, answer the result of evaluating argument, exceptionBlock."
	| pattern startPosition currentPosition |
	pattern := subCollection readStream.
	startPosition := self position.
	[ pattern atEnd or: [ self atEnd ] ] whileFalse: [
		self next = pattern next ifFalse: [
			self position: self position - pattern position + 1.
			pattern reset ] ].
	currentPosition := self position.
	self position: startPosition.
	pattern atEnd ifTrue: [ ^currentPosition + 1 - subCollection size ].
	^exceptionBlock value
)

positionOfSubCollection: subCollection = (
	"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.
	If no such match is found, answer 0."
	^self positionOfSubCollection: subCollection ifAbsent: [0]
)

reset = (
	position := 0
)

setToEnd = (
	position := readLimit
)

skip: anInteger = (
	self position: position + anInteger
)

skipTo: anObject = (
	[self atEnd]
		whileFalse: [self next = anObject ifTrue: [^true]].
	^false
)

through: anObject = (
	| newStream element |
	newStream := WriteStream on: (collection species new: 64).
	[(self atEnd or: [(element := self next) = anObject]) or: [newStream size > 64000]]
		whileFalse: [newStream nextPut: element].
	self atEnd
		ifFalse:	[newStream nextPut: element].
	^newStream contents
)

upTo: anObject = (
	| newStream element |
	newStream := WriteStream on: (collection species new: 64).
	[self atEnd or: [(element := self next) = anObject]]
		whileFalse: [newStream nextPut: element].
	^newStream contents
)

upToAll: aCollection = (
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."
	| startPos endMatch result |
	startPos := self position.
	(self match: aCollection)
		ifTrue: [endMatch := self position.
			self position: startPos.
			result := self upToPosition: endMatch - aCollection size.
			self position: endMatch.
			^ result]
		ifFalse: [self position: startPos.
			^ self upToEnd]
)

upToEnd = (
	"Answer a subcollection from the current access position through the last element of the receiver."
	| newStream |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd] whileFalse: [ newStream nextPut: self next ].
	^ newStream contents
)

upToAnyOf: aCollection = (
	"Answer a subcollection from the current access position to the
	occurrence (if any, but not inclusive) of any object in the collection. If
	no matching object is found, answer the entire rest of the receiver."
	^self upToAnyOf: aCollection do: [:matchingObject | ]
)

upToAnyOf: delimiters do: aBlock = (
	| pos |
	collection ifNotNil: [
		(position < readLimit and: [
			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [
				pos > 0 ] ]) ifTrue: [
					| result |
					result := collection copyFrom: position + 1 to: (position := pos) - 1 .
					aBlock value: (collection at: position).
					^result ] ].
	^self collectionSpecies streamContents: [ :stream |
		| buffer bytesRead |
		buffer := collection
			ifNil: [ self collectionSpecies new: 2000 ]
			ifNotNil: [
				position < readLimit ifTrue: [
					stream next: readLimit - position putAll: collection startingAt: position + 1.
					position := readLimit ].
				collection ].
		[
			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.
			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])
				ifTrue: [
					stream next: bytesRead putAll: buffer startingAt: 1.
					bytesRead > 0 "Try again if we could read something last time." ]
				ifFalse: [
					stream next: pos - 1 putAll: buffer startingAt: 1.
					collection
						ifNil: [ self skip: pos - bytesRead ]
						ifNotNil: [
							position := pos.
							readLimit := bytesRead ].
					false "Found the delimiter." ] ] whileTrue.
		bytesRead = 0 ifFalse: [
			aBlock value: (buffer at: pos) ] ]
)

upToPosition: anInteger = (
	"Answer a subcollection containing items starting from the current position and ending including the given position. Usefully different to #next: in that in the case of MultiByteFileStream, and perhaps others, positions measure in terms of encoded items, while #next: convention is to name a number of items, independent of their encoding in the underlying buffer."
	^ self next: anInteger - position
)

----

on: aCollection = (
	^self basicNew on: aCollection
)

on: aCollection from: firstIndex to: lastIndex = (
	^self basicNew on: (aCollection copyFrom: firstIndex to: lastIndex)
)

)
