OrderedCollection = SequenceableCollection (

| array firstIndex lastIndex |

after: oldObject = (
	| index |
	index := self find: oldObject.
	index = lastIndex ifTrue: [ ^self errorLastObject ] ifFalse: [ ^array at: index + 1 ]
)

asArray = (
	| result size |
	result := Array new: (size := self size).
	result
		replaceFrom: 1
		to: size
		with: array
		startingAt: firstIndex.
	^result
)

at: anInteger = (
	(anInteger < 1 or: [ anInteger + firstIndex - 1 > lastIndex ])
		ifTrue: [ self errorNoSuchElement ]
		ifFalse: [ ^array at: anInteger + firstIndex - 1 ]
)

at: anInteger put: anObject = (
	| index |
	index := anInteger truncated.
	(index < 1 or: [ index + firstIndex - 1 > lastIndex ])
		ifTrue: [ self errorNoSuchElement ]
		ifFalse: [ ^array at: index + firstIndex - 1 put: anObject ]
)

before: oldObject = (
	| index |
	index := self find: oldObject.
	index = firstIndex ifTrue: [ ^self errorFirstObject ] ifFalse: [ ^array at: index - 1 ]
)

first = (
	self emptyCheck.
	^array at: firstIndex
)

last = (
	self emptyCheck.
	^array at: lastIndex
)

size = (
	^lastIndex - firstIndex + 1
)

add: newObject = (
	^self addLast: newObject
)

add: newObject after: oldObject = (
	| index |
	index := self find: oldObject.
	self insert: newObject before: index + 1.
	^newObject
)

add: newObject before: oldObject = (
	| index |
	index := self find: oldObject.
	self insert: newObject before: index.
	^newObject
)

addAll: anOrderedCollection = (
	^self addAllLast: anOrderedCollection
)

addAllFirst: anOrderedCollection = (
	anOrderedCollection reverseDo: [ :each | self addFirst: each ].
	^anOrderedCollection
)

addAllLast: anOrderedCollection = (
	anOrderedCollection do: [ :each | self addLast: each ].
	^anOrderedCollection
)

addFirst: newObject = (
	firstIndex = 1 ifTrue: [ self makeRoomAtFirst ].
	firstIndex := firstIndex - 1.
	array at: firstIndex put: newObject.
	^newObject
)

addLast: newObject = (
	lastIndex = array size ifTrue: [ self makeRoomAtLast ].
	lastIndex := lastIndex + 1.
	array at: lastIndex put: newObject.
	^newObject
)

growAtFirst = (
	"Add new empty slots to the front of array, while keeping the empty slots at the end."
	| newArray newFirstIndex newLastIndex |
	newArray := self class arrayType new: (array size * 2 max: 1).
	newFirstIndex := newArray size - array size + firstIndex.
	newLastIndex := newFirstIndex + lastIndex - firstIndex.
	newArray
		replaceFrom: newFirstIndex
		to: newLastIndex
		with: array
		startingAt: firstIndex.
	array := newArray.
	firstIndex := newFirstIndex.
	lastIndex := newLastIndex
)

growAtLast = (
	"Add new empty slots to the end of array, while keeping the empty slots at the front."
	| newArray |
	newArray := self class arrayType new: (array size * 2 max: 1).
	newArray
		replaceFrom: firstIndex
		to: lastIndex
		with: array
		startingAt: firstIndex.
	array := newArray
)

copyEmpty = (
	^self species new
)

copyFrom: startIndex to: endIndex = (
	| targetCollection index |
	endIndex < startIndex ifTrue: [ ^self species new: 0 ].
	targetCollection := self species new: endIndex + 1 - startIndex.
	startIndex to: endIndex do: [ :index | targetCollection add: (self at: index) ].
	^targetCollection
)

copyReplaceFrom: start to: stop with: replacementCollection = (
	| newOrderedCollection delta newIndex index mySize startIndex stopIndex |
	delta := 0.
	startIndex := start.
	stopIndex := stop.
	(start < 1)
		ifTrue: [ startIndex := stopIndex := 0 ]
		ifFalse: [ startIndex > self size
			ifTrue: [ startIndex := stopIndex := self size + 1 ]
			ifFalse: [
 				(stopIndex < (startIndex - 1) or: [ stopIndex > self size ]) ifTrue: [ self errorOutOfBounds ].
 				delta := stopIndex - startIndex + 1
 			]
 		].
	newOrderedCollection := self species new: self size + replacementCollection size - delta.
	1 to: startIndex - 1 do: [ :index | newOrderedCollection add: (self at: index) ].
	1 to: replacementCollection size do: [ :index | newOrderedCollection add: (replacementCollection at: index) ].
	stopIndex + 1 to: self size do: [ :index | newOrderedCollection add: (self at: index) ].
	^newOrderedCollection
)

copyWith: newElement = (
	| newCollection |
	newCollection := self copy.
	newCollection add: newElement.
	^newCollection
)

copyWithout: oldElement = (
	| newCollection each |
	newCollection := self species new: self size.
	self do: [ :each | oldElement = each ifFalse: [ newCollection add: each ] ].
	^newCollection
)

collect: aBlock = (
	| newCollection |
	newCollection := self species new.
	self do: [ :each | newCollection add: (aBlock value: each) ].
	^newCollection
)

do: aBlock = (
	| index |
	index := firstIndex.
	[ index <= lastIndex ] whileTrue: [
		aBlock value: (array at: index).
		index := index + 1
	]
)

reverse = (
	| newCollection |
	newCollection := self species new.
	self reverseDo: [ :each | newCollection add: each ].
	^newCollection
)

reverseDo: aBlock = (
	| index |
	index := lastIndex.
	[ index >= firstIndex ] whileTrue: [
		aBlock value: (array at: index).
		index := index - 1
	]
)

select: aBlock = (
	| newCollection |
	newCollection := self copyEmpty.
	self do: [ :each | (aBlock value: each) ifTrue: [ newCollection add: each ] ].
	^newCollection
)

errorFirstObject = (
	self error: 'specified object is first objecte'
)

errorLastObject = (
	self error: 'specified object is last object'
)

errorNoSuchElement = (
	self error: 'attempt to index non-existent element in an ordered collection'
)

errorNotFound = (
	self error: 'element not found'
)

find: oldObject = (
	| index |
	index := firstIndex.
	[ index <= lastIndex and: [ oldObject ~= (array at: index) ] ] whileTrue: [ index := index + 1 ].
	index <= lastIndex ifTrue: [ ^index ] ifFalse: [ self errorNotFound ]
)

insert: anObject before: spot = (
	| index delta spotIndex |
	spotIndex := spot.
	delta := spotIndex - firstIndex.
	firstIndex = 1 ifTrue: [ self makeRoomAtFirst.
	spotIndex := firstIndex + delta ].
	index := firstIndex := firstIndex - 1.
	[ index < (spotIndex - 1) ] whileTrue: [ array at: index put: (array at: index + 1). index := index + 1 ].
	array at: index put: anObject.
	^anObject
)

makeRoomAtFirst = (
	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"
	| tally newFirstIndex newLastIndex capacity |
	tally := self size.
	capacity := array size.
	tally * 2 >= capacity ifTrue: [ ^self growAtFirst ].
	tally = 0 ifTrue: [ ^self resetTo: capacity + 1 ].
	newFirstIndex := capacity // 2 + 1.
	newLastIndex := newFirstIndex - firstIndex + lastIndex.
	0 to: tally - 1 do: [ :offset |
		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].
	array from: firstIndex to: newFirstIndex - 1 put: nil.
	firstIndex := newFirstIndex.
	lastIndex := newLastIndex
)

makeRoomAtLast = (
	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"
	| tally newFirstIndex newLastIndex |
	tally := self size.
	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].
	tally = 0 ifTrue: [ ^self resetTo: 1 ].
	newLastIndex := lastIndex // 2.
	newFirstIndex := newLastIndex - lastIndex + firstIndex.
	array
		replaceFrom: newFirstIndex
		to: newLastIndex
		with: array
		startingAt: firstIndex.
	array from: newLastIndex + 1 to: lastIndex put: nil.
	firstIndex := newFirstIndex.
	lastIndex := newLastIndex
)

removeIndex: removedIndex = (
	| index |
	index := removedIndex.
	[ index < lastIndex ] whileTrue: [
		array at: index put: (array at: index + 1).
		index := index + 1
	].
	array at: lastIndex put: nil.
	lastIndex := lastIndex - 1
)

remove: oldObject ifAbsent: absentBlock = (
	| index |
	index := firstIndex.
	[ index <= lastIndex ] whileTrue: [
		oldObject = (array at: index) ifTrue: [ self removeIndex: index. ^oldObject ] ifFalse: [ index := index + 1 ]
	].
	^absentBlock value
)

removeAllSuchThat: aBlock = (
	| index element newCollection |
	newCollection := self species new.
	index := firstIndex.
	[ index <= lastIndex ] whileTrue: [
		element := array at: index.
 		(aBlock value: element)
			ifTrue: [ newCollection add: element. self removeIndex: index ]
			ifFalse: [ index := index + 1 ]
	].
	^newCollection
)

removeFirst = (
	| firstObject |
	self emptyCheck.
	firstObject := array at: firstIndex.
	array at: firstIndex put: nil.
	firstIndex := firstIndex + 1.
	^firstObject
)

removeLast = (
	| lastObject |
	self emptyCheck.
	lastObject := array at: lastIndex.
	array at: lastIndex put: nil.
	lastIndex := lastIndex - 1.
	^lastObject
)

reset = (
	self resetTo: 1
)

resetTo: index = (
	firstIndex := index.
	lastIndex := firstIndex - 1
)

reverseDo: aBlock = (
	| index |
	index := lastIndex.
	[index >= firstIndex]
		whileTrue:
			[aBlock value: (array at: index).
			index := index - 1]
)

setCollection: anArray = (
	array := anArray.
	self reset
)

----------------------------

arrayType = (
	^ Array
)

new = (
	^ self new: 10
)

new: anInteger = (
	^ self basicNew setCollection: (self arrayType new: anInteger)
)

new: anInteger withAll: anObject = (
	^ self basicNew setContents: (self arrayType new: anInteger withAll: anObject)
)

newFrom: aCollection = (
	| answer |
	answer := self new: aCollection size.
	answer addAll: aCollection.
	^ answer
)

ofSize: n = (
	| collection |
	collection := self new: n.
	collection setContents: (collection collector).
	^ collection
)

)
