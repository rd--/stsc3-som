Integer = Number (

= aNumber = (
	aNumber isInteger ifTrue: [ ^false ].
	aNumber isNumber ifFalse: [ ^false ].
	^aNumber adaptToInteger: self andCompare: #=
)

>> shiftAmount  = (
	"right shift"
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: 0 - shiftAmount
)

allMask: mask = (
	"Treat the argument as a bit mask. Answer whether all of the bits that are 1 in the argument are 1 in the receiver."
	^mask = (self bitAnd: mask)
)

anyMask: mask = (
	"Treat the argument as a bit mask. Answer whether any of the bits that are 1 in the argument are 1 in the receiver."
	^0 ~= (self bitAnd: mask)
)

asCharacter = (
	^Character value: self
)

asInteger = (
	^self
)

bitAt: anInteger = (
	"Answer 1 if the bit at position anInteger is set to 1, 0 otherwise.
	self is considered an infinite sequence of bits, so anInteger can be any strictly positive integer.
	Bit at position 1 is the least significant bit.
	Negative numbers are in two-complements.
	This is a naive implementation that can be refined in subclass for speed"
	^(self bitShift: 1 - anInteger) bitAnd: 1
)

bitInvert = (
	^ -1 - self
)

bitShift: shiftCount = (
	"Answer an Integer whose value (in twos-complement representation) is
	the receiver's value (in twos-complement representation) shifted left by
	the number of bits indicated by the argument. Negative arguments
	shift right. Zeros are shifted in from the right in left shifts."
	| magnitudeShift |
	magnitudeShift := self bitShiftMagnitude: shiftCount.
	^ ((self negative and: [shiftCount negative])
		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])
		ifTrue: [magnitudeShift - 1]
		ifFalse: [magnitudeShift]
)

denominator = (
	"Let an Integer be polymorphic to a Fraction. See #isFraction."
	^1
)

floor = (
)

highBit = (
	^ self subclassResponsibility
)

factorial = (
	self = 0 ifTrue: [^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
)

fractionPart = (
	^0
)

integerPart = (
	^self
)

isInteger = (
	^ true
)

isLiteral = (
	^true
)

isPowerOfTwo = (
	"Return true if the receiver is an integral power of two."
	^self strictlyPositive and: [ (self bitAnd: self - 1) = 0 ]
)

lcm: n = (
	^self // (self gcd: n) * n
)

noMask: mask = (
	"Treat the argument as a bit mask. Answer whether none of the bits that are 1 in the argument are 1 in the receiver."
	^0 = (self bitAnd: mask)
)

printAsLiteralOn: aStream = (
	^self printOn: aStream
)

rounded = (
)

take: kk = (
	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."
	" 6 take: 3  "
	| num denom |
	kk < 0 ifTrue: [^ 0].
	kk > self ifTrue: [^ 0].
	num := 1.
	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num := num * factor].
	denom := 1.
	1 to: (kk min: self-kk) do: [:factor | denom := denom * factor].
	^ num // denom
)

timesRepeat: aBlock = (
	| remaining |
	remaining := self.
	[ (remaining := remaining - 1) >= 0 ] whileTrue: [
		aBlock value ]
)

----

new = (
	self == Integer ifTrue: [^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].
	^ super new
)

)
