Integer = Number (

= aNumber = (
	aNumber isInteger ifTrue: [ ^false ].
	aNumber isNumber ifFalse: [ ^false ].
	^aNumber adaptToInteger: self andCompare: #=
)

>> shiftAmount  = (
	"right shift"
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: 0 - shiftAmount
)

allMask: mask = (
	"Treat the argument as a bit mask. Answer whether all of the bits that are 1 in the argument are 1 in the receiver."
	^mask = (self bitAnd: mask)
)

anyMask: mask = (
	"Treat the argument as a bit mask. Answer whether any of the bits that are 1 in the argument are 1 in the receiver."
	^0 ~= (self bitAnd: mask)
)

asCharacter = (
	^Character value: self
)

asInteger = (
	^self
)

bitAt: anInteger = (
	"Answer 1 if the bit at position anInteger is set to 1, 0 otherwise.
	self is considered an infinite sequence of bits, so anInteger can be any strictly positive integer.
	Bit at position 1 is the least significant bit.
	Negative numbers are in two-complements.
	This is a naive implementation that can be refined in subclass for speed"
	^(self bitShift: 1 - anInteger) bitAnd: 1
)

bitInvert = (
	^ -1 - self
)

bitShift: shiftCount = (
	"Answer an Integer whose value (in twos-complement representation) is
	the receiver's value (in twos-complement representation) shifted left by
	the number of bits indicated by the argument. Negative arguments
	shift right. Zeros are shifted in from the right in left shifts."
	| magnitudeShift |
	magnitudeShift := self bitShiftMagnitude: shiftCount.
	^ ((self negative and: [shiftCount negative])
		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])
		ifTrue: [magnitudeShift - 1]
		ifFalse: [magnitudeShift]
)

denominator = (
	"Let an Integer be polymorphic to a Fraction. See #isFraction."
	^1
)

floor = (
)

highBit = (
	^ self subclassResponsibility
)

factorial = (
	self = 0 ifTrue: [^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
)

fractionPart = (
	^0
)

integerPart = (
	^self
)

isInteger = (
	^ true
)

isLiteral = (
	^true
)

isPowerOfTwo = (
	"Return true if the receiver is an integral power of two."
	^self strictlyPositive and: [ (self bitAnd: self - 1) = 0 ]
)

isProbablyPrime = (
	"See isProbablyPrimeWithK:andQ: for the algoritm description."
	| k q |
	self <= 1 ifTrue: [ ^false ].
	self even ifTrue: [ ^self = 2 ].
	"Factor self into (2 raisedTo: k) * q + 1, where q odd"
	q := self bitShift: -1.
	k := q lowBit.
	q := q bitShift: 1 - k.
	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."
	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].
	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"
	^true
)

isProbablyPrimeWithK: k andQ: q  = (
	"Algorithm P, probabilistic primality test, from
	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,
	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..
	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."
	| x j y minusOne |
	"P1"
	x := (self - 2) atRandom + 1.
	"P2"
	j := 0.
	y := x raisedTo: q modulo: self.
	minusOne := self - 1.
	["P3"
	y = 1 ifTrue: [^j = 0].
	y = minusOne ifTrue: [^true].
	"P4"
	(j := j + 1) < k]
		whileTrue:
			[y := y squared \\ self].
	"P5"
	^false
)

isPrime = (
	"Answer true if the receiver is a prime number. See isProbablyPrime for a probabilistic
	implementation that is much faster for large integers, and that is correct to an extremely
	high statistical level of confidence (effectively deterministic)."
	| probe step limit |
	self <= 3 ifTrue: [ ^self >= 2 ].
	self \\ 2 = 0 ifTrue: [ ^false ].
	self \\ 3 = 0 ifTrue: [ ^false ].
	self <= 1073741823 ifFalse: [ "1 << 30 - 1. For numbers larger than this (on 64-bit platforms) #isProbablyPrime is usually quicker."
		^self isProbablyPrime ].
	probe := 5.
	step := 2. "Step will oscillate between 2 and 4 because at this point self \\ 6 is either 1 or 5."
	limit := self sqrtFloor. "On 64-bit platforms this could be written as self asFloat sqrt truncated (+ 1), which is faster because it creates no intermediate objects. Knowing that self has at most 30 bits because of the check above, this value will never be larger than 32767."
	[ probe <= limit ] whileTrue: [
		self \\ probe = 0 ifTrue: [ ^false ].
		probe := probe + step.
		step := 6 - step ].
	^true
)

lcm: n = (
	^self // (self gcd: n) * n
)

noMask: mask = (
	"Treat the argument as a bit mask. Answer whether none of the bits that are 1 in the argument are 1 in the receiver."
	^0 = (self bitAnd: mask)
)

printAsLiteralOn: aStream = (
	^self printOn: aStream
)

rounded = (
)

sqrtFloor = (
	"Return the integer part of the square root of self
	Assume self >= 0
	The following post-conditions apply:
	1) self sqrtFloor squared <= self
	2) (self sqrtFloor + 1) squared > self"
	self subclassResponsibility
)

take: kk = (
	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."
	" 6 take: 3  "
	| num denom |
	kk < 0 ifTrue: [^ 0].
	kk > self ifTrue: [^ 0].
	num := 1.
	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num := num * factor].
	denom := 1.
	1 to: (kk min: self-kk) do: [:factor | denom := denom * factor].
	^ num // denom
)

timesRepeat: aBlock = (
	| remaining |
	remaining := self.
	[ (remaining := remaining - 1) >= 0 ] whileTrue: [
		aBlock value ]
)

truncated = (
	"Refer to the comment in Number|truncated."
)

----

new = (
	self == Integer ifTrue: [^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].
	^ super new
)


primesUpTo: max = (
	"Return a list of prime integers up to the given integer."
	"Integer primesUpTo: 100"
	^Array streamContents:[:s| self primesUpTo: max do:[:prime| s nextPut: prime]]
)

primesUpTo: max do: aBlock = (
	"Compute aBlock with all prime integers up to the given integer."
	"Integer primesUpTo: 100"
	| index sieve increment limit limitSqrtFloor |
	limit := max asInteger.
	limit := limit - 1. "upTo:"
	limit <= 1 ifTrue: [ ^self ].
	aBlock value: 2.
	limit <= 2 ifTrue: [ ^self ].
	aBlock value: 3.
	sieve := Array new: limit withAll: 1. "1 = prime, 0 = not prime"
	sieve at: 1 put: 0.
	"Filter multiples of 2."
	index := 4.
	[ index <= limit ] whileTrue: [
		sieve at: index put: 0.
		index := index + 2 ].
	"Filter multiples of 3."
	index := 9.
	[ index <= limit ] whileTrue: [
		sieve at: index put: 0.
		index := index + 3 ].
	"Filter the rest of the primes."
	limitSqrtFloor := limit sqrtFloor.
	index := 5.
	increment := 2.
	[ index <= limitSqrtFloor ] whileTrue: [
		(sieve at: index) = 1 ifTrue: [
			| originalIndex originalIncrement |
			aBlock value: index.
			originalIndex := index.
			originalIncrement := increment.
			increment := index + index.
			index := index * index.
			[ index <= limit ] whileTrue: [
				sieve at: index put: 0.
				index := index + increment ].
			index := originalIndex.
			increment := originalIncrement ].
		index := index + increment.
		increment := 6 - increment ].
	"No more new primes here."
	[ index <= limit ] whileTrue: [
		(sieve at: index) = 1 ifTrue: [
			aBlock value: index ].
		index := index + increment.
		increment := 6 - increment ]
)

)
