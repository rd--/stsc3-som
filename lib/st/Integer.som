Integer = Number (

= aNumber = (
	aNumber isInteger ifTrue: [ ^false ].
	aNumber isNumber ifFalse: [ ^false ].
	^aNumber adaptToInteger: self andCompare: #=
)

asCharacter = (
	^Character value: self
)

asInteger = (
	^self
)

bitInvert = (
	^ -1 - self
)

denominator = (
	"Let an Integer be polymorphic to a Fraction. See #isFraction."
	^1
)

floor = (
)

highBit = (
	^ self subclassResponsibility
)

factorial = (
	self = 0 ifTrue: [^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
)

fractionPart = (
	^0
)

integerPart = (
	^self
)

isInteger = (
	^ true
)

isLiteral = (
	^true
)

isPowerOfTwo = (
	"Return true if the receiver is an integral power of two."
	^self strictlyPositive and: [ (self bitAnd: self - 1) = 0 ]
)

lcm: n = (
	^self // (self gcd: n) * n
)

printAsLiteralOn: aStream = (
	^self printOn: aStream
)

rounded = (
)

timesRepeat: aBlock = (
	| remaining |
	remaining := self.
	[ (remaining := remaining - 1) >= 0 ] whileTrue: [
		aBlock value ]
)

----

new = (
	self == Integer ifTrue: [^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].
	^ super new
)

)
